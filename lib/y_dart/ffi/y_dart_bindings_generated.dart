// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field
// ignore_for_file: unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// For historical reasons; programs expect signal's return value to be
/// defined by <sys/signal.h>.
@ffi.Native<
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>(
    symbol: 'signal', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
  int arg0,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
);

@ffi.Native<ffi.Int Function(ffi.Int, id_t)>(
    symbol: 'getpriority', assetId: 'package:y_dart/y_dart')
external int getpriority(
  int arg0,
  int arg1,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Int)>(
    symbol: 'getiopolicy_np', assetId: 'package:y_dart/y_dart')
external int getiopolicy_np(
  int arg0,
  int arg1,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>(
    symbol: 'getrlimit', assetId: 'package:y_dart/y_dart')
external int getrlimit(
  int arg0,
  ffi.Pointer<rlimit> arg1,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>(
    symbol: 'getrusage', assetId: 'package:y_dart/y_dart')
external int getrusage(
  int arg0,
  ffi.Pointer<rusage> arg1,
);

@ffi.Native<ffi.Int Function(ffi.Int, id_t, ffi.Int)>(
    symbol: 'setpriority', assetId: 'package:y_dart/y_dart')
external int setpriority(
  int arg0,
  int arg1,
  int arg2,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>(
    symbol: 'setiopolicy_np', assetId: 'package:y_dart/y_dart')
external int setiopolicy_np(
  int arg0,
  int arg1,
  int arg2,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>(
    symbol: 'setrlimit', assetId: 'package:y_dart/y_dart')
external int setrlimit(
  int arg0,
  ffi.Pointer<rlimit> arg1,
);

@ffi.Native<pid_t Function(ffi.Pointer<ffi.Int>)>(
    symbol: 'wait', assetId: 'package:y_dart/y_dart')
external int wait1(
  ffi.Pointer<ffi.Int> arg0,
);

@ffi.Native<pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>(
    symbol: 'waitpid', assetId: 'package:y_dart/y_dart')
external int waitpid(
  int arg0,
  ffi.Pointer<ffi.Int> arg1,
  int arg2,
);

@ffi.Native<ffi.Int Function(ffi.Int32, id_t, ffi.Pointer<siginfo_t>, ffi.Int)>(
    symbol: 'waitid', assetId: 'package:y_dart/y_dart')
external int waitid(
  int arg0,
  int arg1,
  ffi.Pointer<siginfo_t> arg2,
  int arg3,
);

@ffi.Native<pid_t Function(ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>(
    symbol: 'wait3', assetId: 'package:y_dart/y_dart')
external int wait3(
  ffi.Pointer<ffi.Int> arg0,
  int arg1,
  ffi.Pointer<rusage> arg2,
);

@ffi.Native<
    pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
        ffi.Pointer<rusage>)>(symbol: 'wait4', assetId: 'package:y_dart/y_dart')
external int wait4(
  int arg0,
  ffi.Pointer<ffi.Int> arg1,
  int arg2,
  ffi.Pointer<rusage> arg3,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size)>(
    symbol: 'alloca', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> alloca(
  int arg0,
);

/// <malloc/_malloc.h>
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_malloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_malloc(
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_calloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_calloc(
  int count,
  int size,
  int type_id,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, malloc_type_id_t)>(
    symbol: 'malloc_type_free', assetId: 'package:y_dart/y_dart')
external void malloc_type_free(
  ffi.Pointer<ffi.Void> ptr,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Void>, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_realloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_realloc(
  ffi.Pointer<ffi.Void> ptr,
  int size,
  int type_id,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_valloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_valloc(
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_aligned_alloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
  int alignment,
  int size,
  int type_id,
);

/// rdar://75598414 (Support __counted_by_or_null)
@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size, ffi.Size,
            malloc_type_id_t)>(
    symbol: 'malloc_type_posix_memalign', assetId: 'package:y_dart/y_dart')
external int malloc_type_posix_memalign(
  ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
  int alignment,
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<malloc_zone_t>, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_zone_malloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
  ffi.Pointer<malloc_zone_t> zone,
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<malloc_zone_t>, ffi.Size, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_zone_calloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
  ffi.Pointer<malloc_zone_t> zone,
  int count,
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
            malloc_type_id_t)>(
    symbol: 'malloc_type_zone_free', assetId: 'package:y_dart/y_dart')
external void malloc_type_zone_free(
  ffi.Pointer<malloc_zone_t> zone,
  ffi.Pointer<ffi.Void> ptr,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>,
            ffi.Pointer<ffi.Void>, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_zone_realloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
  ffi.Pointer<malloc_zone_t> zone,
  ffi.Pointer<ffi.Void> ptr,
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<malloc_zone_t>, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_zone_valloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
  ffi.Pointer<malloc_zone_t> zone,
  int size,
  int type_id,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<malloc_zone_t>, ffi.Size, ffi.Size, malloc_type_id_t)>(
    symbol: 'malloc_type_zone_memalign', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
  ffi.Pointer<malloc_zone_t> zone,
  int alignment,
  int size,
  int type_id,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size)>(
    symbol: 'malloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> malloc(
  int __size,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>(
    symbol: 'calloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> calloc(
  int __count,
  int __size,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    symbol: 'free', assetId: 'package:y_dart/y_dart')
external void free(
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)>(
    symbol: 'realloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> realloc(
  ffi.Pointer<ffi.Void> __ptr,
  int __size,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)>(
    symbol: 'reallocf', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> reallocf(
  ffi.Pointer<ffi.Void> __ptr,
  int __size,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size)>(
    symbol: 'valloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> valloc(
  int arg0,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>(
    symbol: 'aligned_alloc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> aligned_alloc(
  int __alignment,
  int __size,
);

/// rdar://75598414 (Support __counted_by_or_null)
@ffi.Native<
    ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
        ffi.Size)>(symbol: 'posix_memalign', assetId: 'package:y_dart/y_dart')
external int posix_memalign(
  ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
  int __alignment,
  int __size,
);

@ffi.Native<ffi.Void Function()>(
    symbol: 'abort', assetId: 'package:y_dart/y_dart')
external void abort();

@ffi.Native<ffi.Int Function(ffi.Int)>(
    symbol: 'abs', assetId: 'package:y_dart/y_dart')
external int abs(
  int arg0,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: 'atexit', assetId: 'package:y_dart/y_dart')
external int atexit(
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'atof', assetId: 'package:y_dart/y_dart')
external double atof(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'atoi', assetId: 'package:y_dart/y_dart')
external int atoi(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'atol', assetId: 'package:y_dart/y_dart')
external int atol(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'atoll', assetId: 'package:y_dart/y_dart')
external int atoll(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'bsearch', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Void> bsearch(
  ffi.Pointer<ffi.Void> __key,
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      __compar,
);

/// calloc is now declared in _malloc.h
@ffi.Native<div_t Function(ffi.Int, ffi.Int)>(
    symbol: 'div', assetId: 'package:y_dart/y_dart')
external div_t div(
  int arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Int)>(
    symbol: 'exit', assetId: 'package:y_dart/y_dart')
external void exit(
  int arg0,
);

/// free is now declared in _malloc.h
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'getenv', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> getenv(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Long Function(ffi.Long)>(
    symbol: 'labs', assetId: 'package:y_dart/y_dart')
external int labs(
  int arg0,
);

@ffi.Native<ldiv_t Function(ffi.Long, ffi.Long)>(
    symbol: 'ldiv', assetId: 'package:y_dart/y_dart')
external ldiv_t ldiv(
  int arg0,
  int arg1,
);

@ffi.Native<ffi.LongLong Function(ffi.LongLong)>(
    symbol: 'llabs', assetId: 'package:y_dart/y_dart')
external int llabs(
  int arg0,
);

@ffi.Native<lldiv_t Function(ffi.LongLong, ffi.LongLong)>(
    symbol: 'lldiv', assetId: 'package:y_dart/y_dart')
external lldiv_t lldiv(
  int arg0,
  int arg1,
);

/// malloc is now declared in _malloc.h
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>(
    symbol: 'mblen', assetId: 'package:y_dart/y_dart')
external int mblen(
  ffi.Pointer<ffi.Char> __s,
  int __n,
);

@ffi.Native<
    ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
        ffi.Size)>(symbol: 'mbstowcs', assetId: 'package:y_dart/y_dart')
external int mbstowcs(
  ffi.Pointer<ffi.WChar> arg0,
  ffi.Pointer<ffi.Char> arg1,
  int arg2,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
        ffi.Size)>(symbol: 'mbtowc', assetId: 'package:y_dart/y_dart')
external int mbtowc(
  ffi.Pointer<ffi.WChar> arg0,
  ffi.Pointer<ffi.Char> arg1,
  int arg2,
);

/// posix_memalign is now declared in _malloc.h
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'qsort', assetId: 'package:y_dart/y_dart')
external void qsort(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<ffi.Int Function()>(
    symbol: 'rand', assetId: 'package:y_dart/y_dart')
external int rand();

/// realloc is now declared in _malloc.h
@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>(
    symbol: 'srand', assetId: 'package:y_dart/y_dart')
external void srand(
  int arg0,
);

@ffi.Native<
        ffi.Double Function(
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'strtod', assetId: 'package:y_dart/y_dart')
external double strtod(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
);

@ffi.Native<
        ffi.Float Function(
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'strtof', assetId: 'package:y_dart/y_dart')
external double strtof(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
);

@ffi.Native<
    ffi.Long Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtol', assetId: 'package:y_dart/y_dart')
external int strtol(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

@ffi.Native<
    ffi.LongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtoll', assetId: 'package:y_dart/y_dart')
external int strtoll(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtoul', assetId: 'package:y_dart/y_dart')
external int strtoul(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

@ffi.Native<
    ffi.UnsignedLongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtoull', assetId: 'package:y_dart/y_dart')
external int strtoull(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'system', assetId: 'package:y_dart/y_dart')
external int system(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<
    ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
        ffi.Size)>(symbol: 'wcstombs', assetId: 'package:y_dart/y_dart')
external int wcstombs(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.WChar> arg1,
  int arg2,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>(
    symbol: 'wctomb', assetId: 'package:y_dart/y_dart')
external int wctomb(
  ffi.Pointer<ffi.Char> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Int)>(
    symbol: '_Exit', assetId: 'package:y_dart/y_dart')
external void _Exit(
  int arg0,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'a64l', assetId: 'package:y_dart/y_dart')
external int a64l(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Double Function()>(
    symbol: 'drand48', assetId: 'package:y_dart/y_dart')
external double drand48();

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>)>(symbol: 'ecvt', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ecvt(
  double arg0,
  int arg1,
  ffi.Pointer<ffi.Int> arg2,
  ffi.Pointer<ffi.Int> arg3,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>(
    symbol: 'erand48', assetId: 'package:y_dart/y_dart')
external double erand48(
  ffi.Pointer<ffi.UnsignedShort> arg0,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>)>(symbol: 'fcvt', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> fcvt(
  double arg0,
  int arg1,
  ffi.Pointer<ffi.Int> arg2,
  ffi.Pointer<ffi.Int> arg3,
);

@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>(
    symbol: 'gcvt', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> gcvt(
  double arg0,
  int arg1,
  ffi.Pointer<ffi.Char> arg2,
);

@ffi.Native<
        ffi.Int Function(
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'getsubopt', assetId: 'package:y_dart/y_dart')
external int getsubopt(
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
);

@ffi.Native<ffi.Int Function(ffi.Int)>(
    symbol: 'grantpt', assetId: 'package:y_dart/y_dart')
external int grantpt(
  int arg0,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
        ffi.Size)>(symbol: 'initstate', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> initstate(
  int arg0,
  ffi.Pointer<ffi.Char> arg1,
  int arg2,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>(
    symbol: 'jrand48', assetId: 'package:y_dart/y_dart')
external int jrand48(
  ffi.Pointer<ffi.UnsignedShort> arg0,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Long)>(
    symbol: 'l64a', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> l64a(
  int arg0,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>(
    symbol: 'lcong48', assetId: 'package:y_dart/y_dart')
external void lcong48(
  ffi.Pointer<ffi.UnsignedShort> arg0,
);

@ffi.Native<ffi.Long Function()>(
    symbol: 'lrand48', assetId: 'package:y_dart/y_dart')
external int lrand48();

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'mktemp', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> mktemp(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'mkstemp', assetId: 'package:y_dart/y_dart')
external int mkstemp(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Long Function()>(
    symbol: 'mrand48', assetId: 'package:y_dart/y_dart')
external int mrand48();

@ffi.Native<ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>(
    symbol: 'nrand48', assetId: 'package:y_dart/y_dart')
external int nrand48(
  ffi.Pointer<ffi.UnsignedShort> arg0,
);

@ffi.Native<ffi.Int Function(ffi.Int)>(
    symbol: 'posix_openpt', assetId: 'package:y_dart/y_dart')
external int posix_openpt(
  int arg0,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int)>(
    symbol: 'ptsname', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ptsname(
  int arg0,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>(
    symbol: 'ptsname_r', assetId: 'package:y_dart/y_dart')
external int ptsname_r(
  int fildes,
  ffi.Pointer<ffi.Char> buffer,
  int buflen,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'putenv', assetId: 'package:y_dart/y_dart')
external int putenv(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Long Function()>(
    symbol: 'random', assetId: 'package:y_dart/y_dart')
external int random();

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>(
    symbol: 'rand_r', assetId: 'package:y_dart/y_dart')
external int rand_r(
  ffi.Pointer<ffi.UnsignedInt> arg0,
);

@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realpath', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> realpath(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<
        ffi.Pointer<ffi.UnsignedShort> Function(
            ffi.Pointer<ffi.UnsignedShort>)>(
    symbol: 'seed48', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.UnsignedShort> seed48(
  ffi.Pointer<ffi.UnsignedShort> arg0,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
        ffi.Int)>(symbol: 'setenv', assetId: 'package:y_dart/y_dart')
external int setenv(
  ffi.Pointer<ffi.Char> __name,
  ffi.Pointer<ffi.Char> __value,
  int __overwrite,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'setkey', assetId: 'package:y_dart/y_dart')
external void setkey(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'setstate', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> setstate(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Void Function(ffi.Long)>(
    symbol: 'srand48', assetId: 'package:y_dart/y_dart')
external void srand48(
  int arg0,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>(
    symbol: 'srandom', assetId: 'package:y_dart/y_dart')
external void srandom(
  int arg0,
);

@ffi.Native<ffi.Int Function(ffi.Int)>(
    symbol: 'unlockpt', assetId: 'package:y_dart/y_dart')
external int unlockpt(
  int arg0,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'unsetenv', assetId: 'package:y_dart/y_dart')
external int unsetenv(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<ffi.Uint32 Function()>(
    symbol: 'arc4random', assetId: 'package:y_dart/y_dart')
external int arc4random();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>(
    symbol: 'arc4random_addrandom', assetId: 'package:y_dart/y_dart')
external void arc4random_addrandom(
  ffi.Pointer<ffi.UnsignedChar> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>(
    symbol: 'arc4random_buf', assetId: 'package:y_dart/y_dart')
external void arc4random_buf(
  ffi.Pointer<ffi.Void> __buf,
  int __nbytes,
);

@ffi.Native<ffi.Void Function()>(
    symbol: 'arc4random_stir', assetId: 'package:y_dart/y_dart')
external void arc4random_stir();

@ffi.Native<ffi.Uint32 Function(ffi.Uint32)>(
    symbol: 'arc4random_uniform', assetId: 'package:y_dart/y_dart')
external int arc4random_uniform(
  int __upper_bound,
);

/// getcap(3) functions
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
        ffi.Int)>(symbol: 'cgetcap', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> cgetcap(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
  int arg2,
);

@ffi.Native<ffi.Int Function()>(
    symbol: 'cgetclose', assetId: 'package:y_dart/y_dart')
external int cgetclose();

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>(
    symbol: 'cgetent', assetId: 'package:y_dart/y_dart')
external int cgetent(
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ffi.Pointer<ffi.Char> arg2,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'cgetfirst', assetId: 'package:y_dart/y_dart')
external int cgetfirst(
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'cgetmatch', assetId: 'package:y_dart/y_dart')
external int cgetmatch(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'cgetnext', assetId: 'package:y_dart/y_dart')
external int cgetnext(
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Long>)>(
    symbol: 'cgetnum', assetId: 'package:y_dart/y_dart')
external int cgetnum(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
  ffi.Pointer<ffi.Long> arg2,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'cgetset', assetId: 'package:y_dart/y_dart')
external int cgetset(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'cgetstr', assetId: 'package:y_dart/y_dart')
external int cgetstr(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'cgetustr', assetId: 'package:y_dart/y_dart')
external int cgetustr(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.Char> arg1,
  ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Int)>(
    symbol: 'daemon', assetId: 'package:y_dart/y_dart')
external int daemon(
  int arg0,
  int arg1,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>(
    symbol: 'devname', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> devname(
  int arg0,
  int arg1,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(dev_t, mode_t, ffi.Pointer<ffi.Char>,
        ffi.Int)>(symbol: 'devname_r', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> devname_r(
  int arg0,
  int arg1,
  ffi.Pointer<ffi.Char> buf,
  int len,
);

@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>(
    symbol: 'getbsize', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> getbsize(
  ffi.Pointer<ffi.Int> arg0,
  ffi.Pointer<ffi.Long> arg1,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>(
    symbol: 'getloadavg', assetId: 'package:y_dart/y_dart')
external int getloadavg(
  ffi.Pointer<ffi.Double> arg0,
  int arg1,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function()>(
    symbol: 'getprogname', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> getprogname();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'setprogname', assetId: 'package:y_dart/y_dart')
external void setprogname(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<
        ffi.Int Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'heapsort', assetId: 'package:y_dart/y_dart')
external int heapsort(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<
        ffi.Int Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'mergesort', assetId: 'package:y_dart/y_dart')
external int mergesort(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'psort', assetId: 'package:y_dart/y_dart')
external void psort(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'psort_r', assetId: 'package:y_dart/y_dart')
external void psort_r(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<ffi.Void> arg3,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Int Function(ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>(
    symbol: 'qsort_r', assetId: 'package:y_dart/y_dart')
external void qsort_r(
  ffi.Pointer<ffi.Void> __base,
  int __nel,
  int __width,
  ffi.Pointer<ffi.Void> arg3,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>
      __compar,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.UnsignedInt)>(symbol: 'radixsort', assetId: 'package:y_dart/y_dart')
external int radixsort(
  ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
  int __nel,
  ffi.Pointer<ffi.UnsignedChar> __table,
  int __endbyte,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'rpmatch', assetId: 'package:y_dart/y_dart')
external int rpmatch(
  ffi.Pointer<ffi.Char> arg0,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>(
    symbol: 'sradixsort', assetId: 'package:y_dart/y_dart')
external int sradixsort(
  ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
  int __nel,
  ffi.Pointer<ffi.UnsignedChar> __table,
  int __endbyte,
);

@ffi.Native<ffi.Void Function()>(
    symbol: 'sranddev', assetId: 'package:y_dart/y_dart')
external void sranddev();

@ffi.Native<ffi.Void Function()>(
    symbol: 'srandomdev', assetId: 'package:y_dart/y_dart')
external void srandomdev();

/// reallocf is now declared in _malloc.h
@ffi.Native<
        ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong, ffi.LongLong,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'strtonum', assetId: 'package:y_dart/y_dart')
external int strtonum(
  ffi.Pointer<ffi.Char> __numstr,
  int __minval,
  int __maxval,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
);

@ffi.Native<
    ffi.LongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtoq', assetId: 'package:y_dart/y_dart')
external int strtoq(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

@ffi.Native<
    ffi.UnsignedLongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'strtouq', assetId: 'package:y_dart/y_dart')
external int strtouq(
  ffi.Pointer<ffi.Char> __str,
  ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  int __base,
);

/// Returns default ceonfiguration for `YOptions`.
@ffi.Native<YOptions Function()>(
    symbol: 'yoptions', assetId: 'package:y_dart/y_dart')
external YOptions yoptions();

/// Releases all memory-allocated resources bound to given document.
@ffi.Native<ffi.Void Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_destroy', assetId: 'package:y_dart/y_dart')
external void ydoc_destroy(
  ffi.Pointer<YDoc> value,
);

/// Frees all memory-allocated resources bound to a given [YMapEntry].
@ffi.Native<ffi.Void Function(ffi.Pointer<YMapEntry>)>(
    symbol: 'ymap_entry_destroy', assetId: 'package:y_dart/y_dart')
external void ymap_entry_destroy(
  ffi.Pointer<YMapEntry> value,
);

/// Frees all memory-allocated resources bound to a given [YXmlAttr].
@ffi.Native<ffi.Void Function(ffi.Pointer<YXmlAttr>)>(
    symbol: 'yxmlattr_destroy', assetId: 'package:y_dart/y_dart')
external void yxmlattr_destroy(
  ffi.Pointer<YXmlAttr> attr,
);

/// Frees all memory-allocated resources bound to a given UTF-8 null-terminated string returned from
/// Yrs document API. Yrs strings don't use libc malloc, so calling `free()` on them will fault.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'ystring_destroy', assetId: 'package:y_dart/y_dart')
external void ystring_destroy(
  ffi.Pointer<ffi.Char> str,
);

@ffi.Native<ffi.Pointer<YBinaryDestroyInput> Function()>(
    symbol: 'ybinary_destroy_struct', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YBinaryDestroyInput> ybinary_destroy_struct();

@ffi.Native<ffi.Void Function(ffi.Pointer<YBinaryDestroyInput>)>(
    symbol: 'ybinary_destroy_from_struct', assetId: 'package:y_dart/y_dart')
external void ybinary_destroy_from_struct(
  ffi.Pointer<YBinaryDestroyInput> input,
);

/// Frees all memory-allocated resources bound to a given binary returned from Yrs document API.
/// Unlike strings binaries are not null-terminated and can contain null characters inside,
/// therefore a size of memory to be released must be explicitly provided.
/// Yrs binaries don't use libc malloc, so calling `free()` on them will fault.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'ybinary_destroy', assetId: 'package:y_dart/y_dart')
external void ybinary_destroy(
  ffi.Pointer<ffi.Char> ptr,
  int len,
);

/// Creates a new [Doc] instance with a randomized unique client identifier.
///
/// Use [ydoc_destroy] in order to release created [Doc] resources.
@ffi.Native<ffi.Pointer<YDoc> Function()>(
    symbol: 'ydoc_new', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDoc> ydoc_new();

/// Creates a shallow clone of a provided `doc` - it's realized by increasing the ref-count
/// value of the document. In result both input and output documents point to the same instance.
///
/// Documents created this way can be destroyed via [ydoc_destroy] - keep in mind, that the memory
/// will still be persisted until all strong references are dropped.
@ffi.Native<ffi.Pointer<YDoc> Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_clone', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDoc> ydoc_clone(
  ffi.Pointer<YDoc> doc,
);

/// Creates a new [Doc] instance with a specified `options`.
///
/// Use [ydoc_destroy] in order to release created [Doc] resources.
@ffi.Native<ffi.Pointer<YDoc> Function(YOptions)>(
    symbol: 'ydoc_new_with_options', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDoc> ydoc_new_with_options(
  YOptions options,
);

/// Returns a unique client identifier of this [Doc] instance.
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_id', assetId: 'package:y_dart/y_dart')
external int ydoc_id(
  ffi.Pointer<YDoc> doc,
);

/// Returns a unique document identifier of this [Doc] instance.
///
/// Generated string resources should be released using [ystring_destroy] function.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_guid', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ydoc_guid(
  ffi.Pointer<YDoc> doc,
);

/// Returns a collection identifier of this [Doc] instance.
/// If none was defined, a `NULL` will be returned.
///
/// Generated string resources should be released using [ystring_destroy] function.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_collection_id', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ydoc_collection_id(
  ffi.Pointer<YDoc> doc,
);

/// Returns status of should_load flag of this [Doc] instance, informing parent [Doc] if this
/// document instance requested a data load.
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_should_load', assetId: 'package:y_dart/y_dart')
external int ydoc_should_load(
  ffi.Pointer<YDoc> doc,
);

/// Returns status of auto_load flag of this [Doc] instance. Auto loaded sub-documents automatically
/// send a load request to their parent documents.
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_auto_load', assetId: 'package:y_dart/y_dart')
external int ydoc_auto_load(
  ffi.Pointer<YDoc> doc,
);

@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YDoc>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
                        ffi.Pointer<ffi.Char>)>>)>(
    symbol: 'ydoc_observe_updates_v1', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ydoc_observe_updates_v1(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Pointer<ffi.Char>)>>
      cb,
);

@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YDoc>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
                        ffi.Pointer<ffi.Char>)>>)>(
    symbol: 'ydoc_observe_updates_v2', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ydoc_observe_updates_v2(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Pointer<ffi.Char>)>>
      cb,
);

@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YDoc>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.Void>,
                        ffi.Pointer<YAfterTransactionEvent>)>>)>(
    symbol: 'ydoc_observe_after_transaction', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ydoc_observe_after_transaction(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YAfterTransactionEvent>)>>
      cb,
);

@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YDoc>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YSubdocsEvent>)>>)>(
    symbol: 'ydoc_observe_subdocs', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ydoc_observe_subdocs(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YSubdocsEvent>)>>
      cb,
);

@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YDoc>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YDoc>)>>)>(
    symbol: 'ydoc_observe_clear', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ydoc_observe_clear(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<YDoc>)>>
      cb,
);

/// Manually send a load request to a parent document of this subdoc.
@ffi.Native<ffi.Void Function(ffi.Pointer<YDoc>, ffi.Pointer<YTransaction>)>(
    symbol: 'ydoc_load', assetId: 'package:y_dart/y_dart')
external void ydoc_load(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<YTransaction> parent_txn,
);

/// Destroys current document, sending a 'destroy' event and clearing up all the event callbacks
/// registered.
@ffi.Native<ffi.Void Function(ffi.Pointer<YDoc>, ffi.Pointer<YTransaction>)>(
    symbol: 'ydoc_clear', assetId: 'package:y_dart/y_dart')
external void ydoc_clear(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<YTransaction> parent_txn,
);

/// Starts a new read-only transaction on a given document. All other operations happen in context
/// of a transaction. Yrs transactions do not follow ACID rules. Once a set of operations is
/// complete, a transaction can be finished using `ytransaction_commit` function.
///
/// Returns `NULL` if read-only transaction couldn't be created, i.e. when another read-write
/// transaction is already opened.
@ffi.Native<ffi.Pointer<YTransaction> Function(ffi.Pointer<YDoc>)>(
    symbol: 'ydoc_read_transaction', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YTransaction> ydoc_read_transaction(
  ffi.Pointer<YDoc> doc,
);

/// Starts a new read-write transaction on a given document. All other operations happen in context
/// of a transaction. Yrs transactions do not follow ACID rules. Once a set of operations is
/// complete, a transaction can be finished using `ytransaction_commit` function.
///
/// `origin_len` and `origin` are optional parameters to specify a byte sequence used to mark
/// the origin of this transaction (eg. you may decide to give different origins for transaction
/// applying remote updates). These can be used by event handlers or `YUndoManager` to perform
/// specific actions. If origin should not be set, call `ydoc_write_transaction(doc, 0, NULL)`.
///
/// Returns `NULL` if read-write transaction couldn't be created, i.e. when another transaction is
/// already opened.
@ffi.Native<
        ffi.Pointer<YTransaction> Function(
            ffi.Pointer<YDoc>, ffi.Uint32, ffi.Pointer<ffi.Char>)>(
    symbol: 'ydoc_write_transaction', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YTransaction> ydoc_write_transaction(
  ffi.Pointer<YDoc> doc,
  int origin_len,
  ffi.Pointer<ffi.Char> origin,
);

/// Returns a list of subdocs existing within current document.
@ffi.Native<
        ffi.Pointer<ffi.Pointer<YDoc>> Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_subdocs', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Pointer<YDoc>> ytransaction_subdocs(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Uint32> len,
);

/// Commit and dispose provided read-write transaction. This operation releases allocated resources,
/// triggers update events and performs a storage compression over all operations executed in scope
/// of a current transaction.
@ffi.Native<ffi.Void Function(ffi.Pointer<YTransaction>)>(
    symbol: 'ytransaction_commit', assetId: 'package:y_dart/y_dart')
external void ytransaction_commit(
  ffi.Pointer<YTransaction> txn,
);

/// Returns `1` if current transaction is of read-write type.
/// Returns `0` if transaction is read-only.
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<YTransaction>)>(
    symbol: 'ytransaction_writeable', assetId: 'package:y_dart/y_dart')
external int ytransaction_writeable(
  ffi.Pointer<YTransaction> txn,
);

/// Gets a reference to shared data type instance at the document root-level,
/// identified by its `name`, which must be a null-terminated UTF-8 compatible string.
///
/// Returns `NULL` if no such structure was defined in the document before.
@ffi.Native<
        ffi.Pointer<Branch> Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ytype_get', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ytype_get(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> name,
);

/// Gets or creates a new shared `YText` data type instance as a root-level type of a given document.
/// This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
/// compatible string.
@ffi.Native<
        ffi.Pointer<Branch> Function(ffi.Pointer<YDoc>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ytext', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ytext(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Char> name,
);

/// Gets or creates a new shared `YArray` data type instance as a root-level type of a given document.
/// This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
/// compatible string.
///
/// Use [yarray_destroy] in order to release pointer returned that way - keep in mind that this will
/// not remove `YArray` instance from the document itself (once created it'll last for the entire
/// lifecycle of a document).
@ffi.Native<
        ffi.Pointer<Branch> Function(ffi.Pointer<YDoc>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yarray', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yarray(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Char> name,
);

/// Gets or creates a new shared `YMap` data type instance as a root-level type of a given document.
/// This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
/// compatible string.
///
/// Use [ymap_destroy] in order to release pointer returned that way - keep in mind that this will
/// not remove `YMap` instance from the document itself (once created it'll last for the entire
/// lifecycle of a document).
@ffi.Native<
        ffi.Pointer<Branch> Function(ffi.Pointer<YDoc>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ymap', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ymap(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Char> name,
);

/// Gets or creates a new shared `YXmlElement` data type instance as a root-level type of a given
/// document. This structure can later be accessed using its `name`, which must be a null-terminated
/// UTF-8 compatible string.
@ffi.Native<
        ffi.Pointer<Branch> Function(ffi.Pointer<YDoc>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmlfragment', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmlfragment(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<ffi.Char> name,
);

/// Returns a state vector of a current transaction's document, serialized using lib0 version 1
/// encoding. Payload created by this function can then be send over the network to a remote peer,
/// where it can be used as a parameter of [ytransaction_state_diff_v1] in order to produce a delta
/// update payload, that can be send back and applied locally in order to efficiently propagate
/// updates from one peer to another.
///
/// The length of a generated binary will be passed within a `len` out parameter.
///
/// Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_state_vector_v1', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_state_vector_v1(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a delta difference between current state of a transaction's document and a state vector
/// `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
/// [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
/// order to propagate and apply (using [ytransaction_apply]) all updates known to a current
/// document, which remote peer was not aware of.
///
/// If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
/// the document.
///
/// A length of an encoded state vector payload must be passed as `sv_len` parameter.
///
/// A length of generated delta diff binary will be passed within a `len` out parameter.
///
/// Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_state_diff_v1', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_state_diff_v1(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> sv,
  int sv_len,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a delta difference between current state of a transaction's document and a state vector
/// `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
/// [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
/// order to propagate and apply (using [ytransaction_apply_v2]) all updates known to a current
/// document, which remote peer was not aware of.
///
/// If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
/// the document.
///
/// A length of an encoded state vector payload must be passed as `sv_len` parameter.
///
/// A length of generated delta diff binary will be passed within a `len` out parameter.
///
/// Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_state_diff_v2', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_state_diff_v2(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> sv,
  int sv_len,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a snapshot descriptor of a current state of the document. This snapshot information
/// can be then used to encode document data at a particular point in time
/// (see: `ytransaction_encode_state_from_snapshot`).
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_snapshot', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_snapshot(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Uint32> len,
);

/// Encodes a state of the document at a point in time specified by the provided `snapshot`
/// (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
///
/// The returned update is binary compatible with Yrs update lib0 v1 encoding, and can be processed
/// with functions dedicated to work on it, like `ytransaction_apply`.
///
/// This function requires document with a GC option flag turned off (otherwise "time travel" would
/// not be a safe operation). If this is not a case, the NULL pointer will be returned.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_encode_state_from_snapshot_v1',
    assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_encode_state_from_snapshot_v1(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> snapshot,
  int snapshot_len,
  ffi.Pointer<ffi.Uint32> len,
);

/// Encodes a state of the document at a point in time specified by the provided `snapshot`
/// (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
///
/// The returned update is binary compatible with Yrs update lib0 v2 encoding, and can be processed
/// with functions dedicated to work on it, like `ytransaction_apply_v2`.
///
/// This function requires document with a GC option flag turned off (otherwise "time travel" would
/// not be a safe operation). If this is not a case, the NULL pointer will be returned.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytransaction_encode_state_from_snapshot_v2',
    assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytransaction_encode_state_from_snapshot_v2(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> snapshot,
  int snapshot_len,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns an unapplied Delete Set for the current document, waiting for missing updates in order
/// to be integrated into document store.
///
/// Return `NULL` if there's no missing delete set and all deletions have been applied.
/// See also: `ytransaction_pending_update`
@ffi.Native<ffi.Pointer<YDeleteSet> Function(ffi.Pointer<YTransaction>)>(
    symbol: 'ytransaction_pending_ds', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDeleteSet> ytransaction_pending_ds(
  ffi.Pointer<YTransaction> txn,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<YDeleteSet>)>(
    symbol: 'ydelete_set_destroy', assetId: 'package:y_dart/y_dart')
external void ydelete_set_destroy(
  ffi.Pointer<YDeleteSet> ds,
);

/// Returns a pending update associated with an underlying `YDoc`. Pending update contains update
/// data waiting for being integrated into main document store. Usually reason for that is that
/// there were missing updates required for integration. In such cases they need to arrive and be
/// integrated first.
///
/// Returns `NULL` if there is not update pending. Returned value can be released by calling
/// `ypending_update_destroy`.
/// See also: `ytransaction_pending_ds`
@ffi.Native<ffi.Pointer<YPendingUpdate> Function(ffi.Pointer<YTransaction>)>(
    symbol: 'ytransaction_pending_update', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPendingUpdate> ytransaction_pending_update(
  ffi.Pointer<YTransaction> txn,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<YPendingUpdate>)>(
    symbol: 'ypending_update_destroy', assetId: 'package:y_dart/y_dart')
external void ypending_update_destroy(
  ffi.Pointer<YPendingUpdate> update,
);

/// Returns a null-terminated UTF-8 encoded string representation of an `update` binary payload,
/// encoded using lib0 v1 encoding.
/// Returns null if update couldn't be parsed into a lib0 v1 formatting.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'yupdate_debug_v1', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yupdate_debug_v1(
  ffi.Pointer<ffi.Char> update,
  int update_len,
);

/// Returns a null-terminated UTF-8 encoded string representation of an `update` binary payload,
/// encoded using lib0 v2 encoding.
/// Returns null if update couldn't be parsed into a lib0 v2 formatting.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'yupdate_debug_v2', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yupdate_debug_v2(
  ffi.Pointer<ffi.Char> update,
  int update_len,
);

/// Applies an diff update (generated by `ytransaction_state_diff_v1`) to a local transaction's
/// document.
///
/// A length of generated `diff` binary must be passed within a `diff_len` out parameter.
///
/// Returns an error code in case if transaction succeeded failed:
/// - **0**: success
/// - `ERR_CODE_IO` (**1**): couldn't read data from input stream.
/// - `ERR_CODE_VAR_INT` (**2**): decoded variable integer outside of the expected integer size bounds.
/// - `ERR_CODE_EOS` (**3**): end of stream found when more data was expected.
/// - `ERR_CODE_UNEXPECTED_VALUE` (**4**): decoded enum tag value was not among known cases.
/// - `ERR_CODE_INVALID_JSON` (**5**): failure when trying to decode JSON content.
/// - `ERR_CODE_OTHER` (**6**): other error type than the one specified.
@ffi.Native<
        ffi.Uint8 Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'ytransaction_apply', assetId: 'package:y_dart/y_dart')
external int ytransaction_apply(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> diff,
  int diff_len,
);

/// Applies an diff update (generated by [ytransaction_state_diff_v2]) to a local transaction's
/// document.
///
/// A length of generated `diff` binary must be passed within a `diff_len` out parameter.
///
/// Returns an error code in case if transaction succeeded failed:
/// - **0**: success
/// - `ERR_CODE_IO` (**1**): couldn't read data from input stream.
/// - `ERR_CODE_VAR_INT` (**2**): decoded variable integer outside of the expected integer size bounds.
/// - `ERR_CODE_EOS` (**3**): end of stream found when more data was expected.
/// - `ERR_CODE_UNEXPECTED_VALUE` (**4**): decoded enum tag value was not among known cases.
/// - `ERR_CODE_INVALID_JSON` (**5**): failure when trying to decode JSON content.
/// - `ERR_CODE_OTHER` (**6**): other error type than the one specified.
@ffi.Native<
        ffi.Uint8 Function(
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'ytransaction_apply_v2', assetId: 'package:y_dart/y_dart')
external int ytransaction_apply_v2(
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> diff,
  int diff_len,
);

/// Returns the length of the `YText` string content in bytes (without the null terminator character)
@ffi.Native<
        ffi.Uint32 Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ytext_len', assetId: 'package:y_dart/y_dart')
external int ytext_len(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
);

/// Returns a null-terminated UTF-8 encoded string content of a current `YText` shared data type.
///
/// Generated string resources should be released using [ystring_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ytext_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ytext_string(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
);

/// Inserts a null-terminated UTF-8 encoded string a given `index`. `index` value must be between
/// 0 and a length of a `YText` (inclusive, accordingly to [ytext_len] return value), otherwise this
/// function will panic.
///
/// A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
/// ownership over a passed value - it will be copied and therefore a string parameter must be
/// released by the caller.
///
/// A nullable pointer with defined `attrs` will be used to wrap provided text with
/// a formatting blocks. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Pointer<ffi.Char>, ffi.Pointer<YInput>)>(
    symbol: 'ytext_insert', assetId: 'package:y_dart/y_dart')
external void ytext_insert(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<ffi.Char> value,
  ffi.Pointer<YInput> attrs,
);

/// Wraps an existing piece of text within a range described by `index`-`len` parameters with
/// formatting blocks containing provided `attrs` metadata. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32, ffi.Pointer<YInput>)>(
    symbol: 'ytext_format', assetId: 'package:y_dart/y_dart')
external void ytext_format(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  int len,
  ffi.Pointer<YInput> attrs,
);

/// Inserts an embed content given `index`. `index` value must be between 0 and a length of a
/// `YText` (inclusive, accordingly to [ytext_len] return value), otherwise this
/// function will panic.
///
/// A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
/// ownership over a passed value - it will be copied and therefore a string parameter must be
/// released by the caller.
///
/// A nullable pointer with defined `attrs` will be used to wrap provided text with
/// a formatting blocks. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Pointer<YInput>, ffi.Pointer<YInput>)>(
    symbol: 'ytext_insert_embed', assetId: 'package:y_dart/y_dart')
external void ytext_insert_embed(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<YInput> content,
  ffi.Pointer<YInput> attrs,
);

/// Performs a series of changes over the given `YText` shared ref type, described by the `delta`
/// parameter:
///
/// - Deltas constructed with `ydelta_input_retain` will move cursor position by the given number
/// of elements. If formatting attributes were defined, all elements skipped over this way will be
/// wrapped by given formatting attributes.
/// - Deltas constructed with `ydelta_input_delete` will tell cursor to remove a corresponding
/// number of elements.
/// - Deltas constructed with `ydelta_input_insert` will tell cursor to insert given elements into
/// current cursor position. While these elements can be of any type (used for embedding ie.
/// shared types or binary payload like images), for the text insertion a `yinput_string`
/// is expected. If formatting attributes were specified, inserted elements will be wrapped by
/// given formatting attributes.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<YDeltaIn>, ffi.Uint32)>(
    symbol: 'ytext_insert_delta', assetId: 'package:y_dart/y_dart')
external void ytext_insert_delta(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<YDeltaIn> delta,
  int delta_len,
);

/// Creates a parameter for `ytext_insert_delta` function. This parameter will move cursor position
/// by the `len` of elements. If formatting `attrs` were defined, all elements skipped over this
/// way will be wrapped by given formatting attributes.
@ffi.Native<YDeltaIn Function(ffi.Uint32, ffi.Pointer<YInput>)>(
    symbol: 'ydelta_input_retain', assetId: 'package:y_dart/y_dart')
external YDeltaIn ydelta_input_retain(
  int len,
  ffi.Pointer<YInput> attrs,
);

/// Creates a parameter for `ytext_insert_delta` function. This parameter will tell cursor to remove
/// a corresponding number of elements, starting from current cursor position.
@ffi.Native<YDeltaIn Function(ffi.Uint32)>(
    symbol: 'ydelta_input_delete', assetId: 'package:y_dart/y_dart')
external YDeltaIn ydelta_input_delete(
  int len,
);

/// Creates a parameter for `ytext_insert_delta` function. This parameter will tell cursor to insert
/// given elements into current cursor position. While these elements can be of any type (used for
/// embedding ie. shared types or binary payload like images), for the text insertion a `yinput_string`
/// is expected. If formatting attributes were specified, inserted elements will be wrapped by
/// given formatting attributes.
@ffi.Native<YDeltaIn Function(ffi.Pointer<YInput>, ffi.Pointer<YInput>)>(
    symbol: 'ydelta_input_insert', assetId: 'package:y_dart/y_dart')
external YDeltaIn ydelta_input_insert(
  ffi.Pointer<YInput> data,
  ffi.Pointer<YInput> attrs,
);

/// Removes a range of characters, starting a a given `index`. This range must fit within the bounds
/// of a current `YText`, otherwise this function call will fail.
///
/// An `index` value must be between 0 and the length of a `YText` (exclusive, accordingly to
/// [ytext_len] return value).
///
/// A `length` must be lower or equal number of characters (counted as UTF chars depending on the
/// encoding configured by `YDoc`) from `index` position to the end of of the string.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32)>(
    symbol: 'ytext_remove_range', assetId: 'package:y_dart/y_dart')
external void ytext_remove_range(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  int length,
);

/// Returns a number of elements stored within current instance of `YArray`.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<Branch>)>(
    symbol: 'yarray_len', assetId: 'package:y_dart/y_dart')
external int yarray_len(
  ffi.Pointer<Branch> array,
);

/// Returns a pointer to a `YOutput` value stored at a given `index` of a current `YArray`.
/// If `index` is outside the bounds of an array, a null pointer will be returned.
///
/// A value returned should be eventually released using [youtput_destroy] function.
@ffi.Native<
    ffi.Pointer<YOutput> Function(
        ffi.Pointer<Branch>,
        ffi.Pointer<YTransaction>,
        ffi.Uint32)>(symbol: 'yarray_get', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yarray_get(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int index,
);

/// Returns a UTF-8 encoded, NULL-terminated JSON string representing a value stored in a current
/// YArray under a given index.
///
/// This method will return `NULL` pointer if value was outside the bound of an array or couldn't be
/// serialized into JSON string.
///
/// This method will also try to serialize complex types that don't have native JSON representation
/// like YMap, YArray, YText etc. in such cases their contents will be materialized into JSON values.
///
/// A string returned should be eventually released using [ystring_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>, ffi.Uint32)>(
    symbol: 'yarray_get_json', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yarray_get_json(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int index,
);

/// Inserts a range of `items` into current `YArray`, starting at given `index`. An `items_len`
/// parameter is used to determine the size of `items` array - it can also be used to insert
/// a single element given its pointer.
///
/// An `index` value must be between 0 and (inclusive) length of a current array (use [yarray_len]
/// to determine its length), otherwise it will panic at runtime.
///
/// `YArray` doesn't take ownership over the inserted `items` data - their contents are being copied
/// into array structure - therefore caller is responsible for freeing all memory associated with
/// input params.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Pointer<YInput>, ffi.Uint32)>(
    symbol: 'yarray_insert_range', assetId: 'package:y_dart/y_dart')
external void yarray_insert_range(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<YInput> items,
  int items_len,
);

/// Removes a `len` of consecutive range of elements from current `array` instance, starting at
/// a given `index`. Range determined by `index` and `len` must fit into boundaries of an array,
/// otherwise it will panic at runtime.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32)>(
    symbol: 'yarray_remove_range', assetId: 'package:y_dart/y_dart')
external void yarray_remove_range(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int index,
  int len,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<Branch>,
        ffi.Pointer<YTransaction>,
        ffi.Uint32,
        ffi.Uint32)>(symbol: 'yarray_move', assetId: 'package:y_dart/y_dart')
external void yarray_move(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int source,
  int target,
);

/// Returns an iterator, which can be used to traverse over all elements of an `array` (`array`'s
/// length can be determined using [yarray_len] function).
///
/// Use [yarray_iter_next] function in order to retrieve a consecutive array elements.
/// Use [yarray_iter_destroy] function in order to close the iterator and release its resources.
@ffi.Native<
        ffi.Pointer<YArrayIter> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yarray_iter', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YArrayIter> yarray_iter(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
);

/// Releases all of an `YArray` iterator resources created by calling [yarray_iter].
@ffi.Native<ffi.Void Function(ffi.Pointer<YArrayIter>)>(
    symbol: 'yarray_iter_destroy', assetId: 'package:y_dart/y_dart')
external void yarray_iter_destroy(
  ffi.Pointer<YArrayIter> iter,
);

/// Moves current `YArray` iterator over to a next element, returning a pointer to it. If an iterator
/// comes to an end of an array, a null pointer will be returned.
///
/// Returned values should be eventually released using [youtput_destroy] function.
@ffi.Native<ffi.Pointer<YOutput> Function(ffi.Pointer<YArrayIter>)>(
    symbol: 'yarray_iter_next', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yarray_iter_next(
  ffi.Pointer<YArrayIter> iterator,
);

/// Returns an iterator, which can be used to traverse over all key-value pairs of a `map`.
///
/// Use [ymap_iter_next] function in order to retrieve a consecutive (**unordered**) map entries.
/// Use [ymap_iter_destroy] function in order to close the iterator and release its resources.
@ffi.Native<
        ffi.Pointer<YMapIter> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ymap_iter', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YMapIter> ymap_iter(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
);

/// Releases all of an `YMap` iterator resources created by calling [ymap_iter].
@ffi.Native<ffi.Void Function(ffi.Pointer<YMapIter>)>(
    symbol: 'ymap_iter_destroy', assetId: 'package:y_dart/y_dart')
external void ymap_iter_destroy(
  ffi.Pointer<YMapIter> iter,
);

/// Moves current `YMap` iterator over to a next entry, returning a pointer to it. If an iterator
/// comes to an end of a map, a null pointer will be returned. Yrs maps are unordered and so are
/// their iterators.
///
/// Returned values should be eventually released using [ymap_entry_destroy] function.
@ffi.Native<ffi.Pointer<YMapEntry> Function(ffi.Pointer<YMapIter>)>(
    symbol: 'ymap_iter_next', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YMapEntry> ymap_iter_next(
  ffi.Pointer<YMapIter> iter,
);

/// Returns a number of entries stored within a `map`.
@ffi.Native<
        ffi.Uint32 Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ymap_len', assetId: 'package:y_dart/y_dart')
external int ymap_len(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
);

/// Inserts a new entry (specified as `key`-`value` pair) into a current `map`. If entry under such
/// given `key` already existed, its corresponding value will be replaced.
///
/// A `key` must be a null-terminated UTF-8 encoded string, which contents will be copied into
/// a `map` (therefore it must be freed by the function caller).
///
/// A `value` content is being copied into a `map`, therefore any of its content must be freed by
/// the function caller.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<YInput>)>(
    symbol: 'ymap_insert', assetId: 'package:y_dart/y_dart')
external void ymap_insert(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<YInput> value,
);

/// Removes a `map` entry, given its `key`. Returns `1` if the corresponding entry was successfully
/// removed or `0` if no entry with a provided `key` has been found inside of a `map`.
///
/// A `key` must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Uint8 Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>)>(
    symbol: 'ymap_remove', assetId: 'package:y_dart/y_dart')
external int ymap_remove(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> key,
);

/// Returns a value stored under the provided `key`, or a null pointer if no entry with such `key`
/// has been found in a current `map`. A returned value is allocated by this function and therefore
/// should be eventually released using [youtput_destroy] function.
///
/// A `key` must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Pointer<YOutput> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ymap_get', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> ymap_get(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> key,
);

/// Returns a value stored under the provided `key` as UTF-8 encoded, NULL-terminated JSON string.
/// Once not needed that string should be deallocated using `ystring_destroy`.
///
/// This method will return `NULL` pointer if value was not found or value couldn't be serialized
/// into JSON string.
///
/// This method will also try to serialize complex types that don't have native JSON representation
/// like YMap, YArray, YText etc. in such cases their contents will be materialized into JSON values.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ymap_get_json', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ymap_get_json(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> key,
);

/// Removes all entries from a current `map`.
@ffi.Native<ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ymap_remove_all', assetId: 'package:y_dart/y_dart')
external void ymap_remove_all(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
);

/// Return a name (or an XML tag) of a current `YXmlElement`. Root-level XML nodes use "UNDEFINED" as
/// their tag names.
///
/// Returned value is a null-terminated UTF-8 string, which must be released using [ystring_destroy]
/// function.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Branch>)>(
    symbol: 'yxmlelem_tag', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yxmlelem_tag(
  ffi.Pointer<Branch> xml,
);

/// Converts current `YXmlElement` together with its children and attributes into a flat string
/// representation (no padding) eg. `<UNDEFINED><title key="value">sample text</title></UNDEFINED>`.
///
/// Returned value is a null-terminated UTF-8 string, which must be released using [ystring_destroy]
/// function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmlelem_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yxmlelem_string(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Inserts an XML attribute described using `attr_name` and `attr_value`. If another attribute with
/// the same name already existed, its value will be replaced with a provided one.
///
/// Both `attr_name` and `attr_value` must be a null-terminated UTF-8 encoded strings. Their
/// contents are being copied, therefore it's up to a function caller to properly release them.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmlelem_insert_attr', assetId: 'package:y_dart/y_dart')
external void yxmlelem_insert_attr(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
  ffi.Pointer<ffi.Char> attr_value,
);

/// Removes an attribute from a current `YXmlElement`, given its name.
///
/// An `attr_name`must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmlelem_remove_attr', assetId: 'package:y_dart/y_dart')
external void yxmlelem_remove_attr(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
);

/// Returns the value of a current `YXmlElement`, given its name, or a null pointer if not attribute
/// with such name has been found. Returned pointer is a null-terminated UTF-8 encoded string, which
/// should be released using [ystring_destroy] function.
///
/// An `attr_name` must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmlelem_get_attr', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yxmlelem_get_attr(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
);

/// Returns an iterator over the `YXmlElement` attributes.
///
/// Use [yxmlattr_iter_next] function in order to retrieve a consecutive (**unordered**) attributes.
/// Use [yxmlattr_iter_destroy] function in order to close the iterator and release its resources.
@ffi.Native<
        ffi.Pointer<YXmlAttrIter> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmlelem_attr_iter', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YXmlAttrIter> yxmlelem_attr_iter(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Returns an iterator over the `YXmlText` attributes.
///
/// Use [yxmlattr_iter_next] function in order to retrieve a consecutive (**unordered**) attributes.
/// Use [yxmlattr_iter_destroy] function in order to close the iterator and release its resources.
@ffi.Native<
        ffi.Pointer<YXmlAttrIter> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmltext_attr_iter', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YXmlAttrIter> yxmltext_attr_iter(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Releases all of attributes iterator resources created by calling [yxmlelem_attr_iter]
/// or [yxmltext_attr_iter].
@ffi.Native<ffi.Void Function(ffi.Pointer<YXmlAttrIter>)>(
    symbol: 'yxmlattr_iter_destroy', assetId: 'package:y_dart/y_dart')
external void yxmlattr_iter_destroy(
  ffi.Pointer<YXmlAttrIter> iterator,
);

/// Returns a next XML attribute from an `iterator`. Attributes are returned in an unordered
/// manner. Once `iterator` reaches the end of attributes collection, a null pointer will be
/// returned.
///
/// Returned value should be eventually released using [yxmlattr_destroy].
@ffi.Native<ffi.Pointer<YXmlAttr> Function(ffi.Pointer<YXmlAttrIter>)>(
    symbol: 'yxmlattr_iter_next', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YXmlAttr> yxmlattr_iter_next(
  ffi.Pointer<YXmlAttrIter> iterator,
);

/// Returns a next sibling of a current XML node, which can be either another `YXmlElement`
/// or a `YXmlText`. Together with [yxmlelem_first_child] it may be used to iterate over the direct
/// children of an XML node (in order to iterate over the nested XML structure use
/// [yxmlelem_tree_walker]).
///
/// If current `YXmlElement` is the last child, this function returns a null pointer.
/// A returned value should be eventually released using [youtput_destroy] function.
@ffi.Native<
        ffi.Pointer<YOutput> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxml_next_sibling', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yxml_next_sibling(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Returns a previous sibling of a current XML node, which can be either another `YXmlElement`
/// or a `YXmlText`.
///
/// If current `YXmlElement` is the first child, this function returns a null pointer.
/// A returned value should be eventually released using [youtput_destroy] function.
@ffi.Native<
        ffi.Pointer<YOutput> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxml_prev_sibling', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yxml_prev_sibling(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Returns a parent `YXmlElement` of a current node, or null pointer when current `YXmlElement` is
/// a root-level shared data type.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<Branch>)>(
    symbol: 'yxmlelem_parent', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmlelem_parent(
  ffi.Pointer<Branch> xml,
);

/// Returns a number of child nodes (both `YXmlElement` and `YXmlText`) living under a current XML
/// element. This function doesn't count a recursive nodes, only direct children of a current node.
@ffi.Native<
        ffi.Uint32 Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmlelem_child_len', assetId: 'package:y_dart/y_dart')
external int yxmlelem_child_len(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Returns a first child node of a current `YXmlElement`, or null pointer if current XML node is
/// empty. Returned value could be either another `YXmlElement` or `YXmlText`.
///
/// A returned value should be eventually released using [youtput_destroy] function.
@ffi.Native<ffi.Pointer<YOutput> Function(ffi.Pointer<Branch>)>(
    symbol: 'yxmlelem_first_child', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yxmlelem_first_child(
  ffi.Pointer<Branch> xml,
);

/// Returns an iterator over a nested recursive structure of a current `YXmlElement`, starting from
/// first of its children. Returned values can be either `YXmlElement` or `YXmlText` nodes.
///
/// Use [yxmlelem_tree_walker_next] function in order to iterate over to a next node.
/// Use [yxmlelem_tree_walker_destroy] function to release resources used by the iterator.
@ffi.Native<
        ffi.Pointer<YXmlTreeWalker> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmlelem_tree_walker', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YXmlTreeWalker> yxmlelem_tree_walker(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
);

/// Releases resources associated with a current XML tree walker iterator.
@ffi.Native<ffi.Void Function(ffi.Pointer<YXmlTreeWalker>)>(
    symbol: 'yxmlelem_tree_walker_destroy', assetId: 'package:y_dart/y_dart')
external void yxmlelem_tree_walker_destroy(
  ffi.Pointer<YXmlTreeWalker> iter,
);

/// Moves current `iterator` to a next value (either `YXmlElement` or `YXmlText`), returning its
/// pointer or a null, if an `iterator` already reached the last successor node.
///
/// Values returned by this function should be eventually released using [youtput_destroy].
@ffi.Native<ffi.Pointer<YOutput> Function(ffi.Pointer<YXmlTreeWalker>)>(
    symbol: 'yxmlelem_tree_walker_next', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yxmlelem_tree_walker_next(
  ffi.Pointer<YXmlTreeWalker> iterator,
);

/// Inserts an `YXmlElement` as a child of a current node at the given `index` and returns its
/// pointer. Node created this way will have a given `name` as its tag (eg. `p` for `<p></p>` node).
///
/// An `index` value must be between 0 and (inclusive) length of a current XML element (use
/// [yxmlelem_child_len] function to determine its length).
///
/// A `name` must be a null-terminated UTF-8 encoded string, which will be copied into current
/// document. Therefore `name` should be freed by the function caller.
@ffi.Native<
        ffi.Pointer<Branch> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Uint32, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmlelem_insert_elem', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmlelem_insert_elem(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<ffi.Char> name,
);

/// Inserts an `YXmlText` as a child of a current node at the given `index` and returns its
/// pointer.
///
/// An `index` value must be between 0 and (inclusive) length of a current XML element (use
/// [yxmlelem_child_len] function to determine its length).
@ffi.Native<
        ffi.Pointer<Branch> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>, ffi.Uint32)>(
    symbol: 'yxmlelem_insert_text', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmlelem_insert_text(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  int index,
);

/// Removes a consecutive range of child elements (of specified length) from the current
/// `YXmlElement`, starting at the given `index`. Specified range must fit into boundaries of current
/// XML node children, otherwise this function will panic at runtime.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32)>(
    symbol: 'yxmlelem_remove_range', assetId: 'package:y_dart/y_dart')
external void yxmlelem_remove_range(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  int index,
  int len,
);

/// Returns an XML child node (either a `YXmlElement` or `YXmlText`) stored at a given `index` of
/// a current `YXmlElement`. Returns null pointer if `index` was outside of the bound of current XML
/// node children.
///
/// Returned value should be eventually released using [youtput_destroy].
@ffi.Native<
    ffi.Pointer<YOutput> Function(
        ffi.Pointer<Branch>,
        ffi.Pointer<YTransaction>,
        ffi.Uint32)>(symbol: 'yxmlelem_get', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yxmlelem_get(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<YTransaction> txn,
  int index,
);

/// Returns the length of the `YXmlText` string content in bytes (without the null terminator
/// character)
@ffi.Native<
        ffi.Uint32 Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmltext_len', assetId: 'package:y_dart/y_dart')
external int yxmltext_len(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
);

/// Returns a null-terminated UTF-8 encoded string content of a current `YXmlText` shared data type.
///
/// Generated string resources should be released using [ystring_destroy] function.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yxmltext_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yxmltext_string(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
);

/// Inserts a null-terminated UTF-8 encoded string a a given `index`. `index` value must be between
/// 0 and a length of a `YXmlText` (inclusive, accordingly to [yxmltext_len] return value), otherwise
/// this function will panic.
///
/// A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
/// ownership over a passed value - it will be copied and therefore a string parameter must be
/// released by the caller.
///
/// A nullable pointer with defined `attrs` will be used to wrap provided text with
/// a formatting blocks. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Pointer<ffi.Char>, ffi.Pointer<YInput>)>(
    symbol: 'yxmltext_insert', assetId: 'package:y_dart/y_dart')
external void yxmltext_insert(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<ffi.Char> str,
  ffi.Pointer<YInput> attrs,
);

/// Inserts an embed content given `index`. `index` value must be between 0 and a length of a
/// `YXmlText` (inclusive, accordingly to [ytext_len] return value), otherwise this
/// function will panic.
///
/// A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
/// ownership over a passed value - it will be copied and therefore a string parameter must be
/// released by the caller.
///
/// A nullable pointer with defined `attrs` will be used to wrap provided text with
/// a formatting blocks. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Pointer<YInput>, ffi.Pointer<YInput>)>(
    symbol: 'yxmltext_insert_embed', assetId: 'package:y_dart/y_dart')
external void yxmltext_insert_embed(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  ffi.Pointer<YInput> content,
  ffi.Pointer<YInput> attrs,
);

/// Wraps an existing piece of text within a range described by `index`-`len` parameters with
/// formatting blocks containing provided `attrs` metadata. `attrs` must be a map-like type.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32, ffi.Pointer<YInput>)>(
    symbol: 'yxmltext_format', assetId: 'package:y_dart/y_dart')
external void yxmltext_format(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int index,
  int len,
  ffi.Pointer<YInput> attrs,
);

/// Removes a range of characters, starting a a given `index`. This range must fit within the bounds
/// of a current `YXmlText`, otherwise this function call will fail.
///
/// An `index` value must be between 0 and the length of a `YXmlText` (exclusive, accordingly to
/// [yxmltext_len] return value).
///
/// A `length` must be lower or equal number of characters (counted as UTF chars depending on the
/// encoding configured by `YDoc`) from `index` position to the end of of the string.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Uint32, ffi.Uint32)>(
    symbol: 'yxmltext_remove_range', assetId: 'package:y_dart/y_dart')
external void yxmltext_remove_range(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  int idx,
  int len,
);

/// Inserts an XML attribute described using `attr_name` and `attr_value`. If another attribute with
/// the same name already existed, its value will be replaced with a provided one.
///
/// Both `attr_name` and `attr_value` must be a null-terminated UTF-8 encoded strings. Their
/// contents are being copied, therefore it's up to a function caller to properly release them.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmltext_insert_attr', assetId: 'package:y_dart/y_dart')
external void yxmltext_insert_attr(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
  ffi.Pointer<ffi.Char> attr_value,
);

/// Removes an attribute from a current `YXmlText`, given its name.
///
/// An `attr_name`must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<Branch>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmltext_remove_attr', assetId: 'package:y_dart/y_dart')
external void yxmltext_remove_attr(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
);

/// Returns the value of a current `YXmlText`, given its name, or a null pointer if not attribute
/// with such name has been found. Returned pointer is a null-terminated UTF-8 encoded string, which
/// should be released using [ystring_destroy] function.
///
/// An `attr_name` must be a null-terminated UTF-8 encoded string.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'yxmltext_get_attr', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yxmltext_get_attr(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> attr_name,
);

/// Returns a collection of chunks representing pieces of `YText` rich text string grouped together
/// by the same formatting rules and type. `chunks_len` is used to inform about a number of chunks
/// generated this way.
///
/// Returned array needs to be eventually deallocated using `ychunks_destroy`.
@ffi.Native<
        ffi.Pointer<YChunk> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytext_chunks', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YChunk> ytext_chunks(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Uint32> chunks_len,
);

/// Deallocates result of `ytext_chunks` method.
@ffi.Native<ffi.Void Function(ffi.Pointer<YChunk>, ffi.Uint32)>(
    symbol: 'ychunks_destroy', assetId: 'package:y_dart/y_dart')
external void ychunks_destroy(
  ffi.Pointer<YChunk> chunks,
  int len,
);

/// Releases all resources related to a corresponding `YOutput` cell.
@ffi.Native<ffi.Void Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_destroy', assetId: 'package:y_dart/y_dart')
external void youtput_destroy(
  ffi.Pointer<YOutput> val,
);

/// Function constructor used to create JSON-like NULL `YInput` cell.
/// This function doesn't allocate any heap resources.
@ffi.Native<YInput Function()>(
    symbol: 'yinput_null', assetId: 'package:y_dart/y_dart')
external YInput yinput_null();

/// Function constructor used to create JSON-like undefined `YInput` cell.
/// This function doesn't allocate any heap resources.
@ffi.Native<YInput Function()>(
    symbol: 'yinput_undefined', assetId: 'package:y_dart/y_dart')
external YInput yinput_undefined();

/// Function constructor used to create JSON-like boolean `YInput` cell.
/// This function doesn't allocate any heap resources.
@ffi.Native<YInput Function(ffi.Uint8)>(
    symbol: 'yinput_bool', assetId: 'package:y_dart/y_dart')
external YInput yinput_bool(
  int flag,
);

/// Function constructor used to create JSON-like 64-bit floating point number `YInput` cell.
/// This function doesn't allocate any heap resources.
@ffi.Native<YInput Function(ffi.Double)>(
    symbol: 'yinput_float', assetId: 'package:y_dart/y_dart')
external YInput yinput_float(
  double num,
);

/// Function constructor used to create JSON-like 64-bit signed integer `YInput` cell.
/// This function doesn't allocate any heap resources.
@ffi.Native<YInput Function(ffi.Int64)>(
    symbol: 'yinput_long', assetId: 'package:y_dart/y_dart')
external YInput yinput_long(
  int integer,
);

/// Function constructor used to create a string `YInput` cell. Provided parameter must be
/// a null-terminated UTF-8 encoded string. This function doesn't allocate any heap resources,
/// and doesn't release any on its own, therefore its up to a caller to free resources once
/// a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'yinput_string', assetId: 'package:y_dart/y_dart')
external YInput yinput_string(
  ffi.Pointer<ffi.Char> str,
);

/// Function constructor used to create aa `YInput` cell representing any JSON-like object.
/// Provided parameter must be a null-terminated UTF-8 encoded JSON string.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'yinput_json', assetId: 'package:y_dart/y_dart')
external YInput yinput_json(
  ffi.Pointer<ffi.Char> str,
);

/// Function constructor used to create a binary `YInput` cell of a specified length.
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'yinput_binary', assetId: 'package:y_dart/y_dart')
external YInput yinput_binary(
  ffi.Pointer<ffi.Char> buf,
  int len,
);

/// Function constructor used to create a JSON-like array `YInput` cell of other JSON-like values of
/// a given length. This function doesn't allocate any heap resources and doesn't release any on its
/// own, therefore its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<YInput>, ffi.Uint32)>(
    symbol: 'yinput_json_array', assetId: 'package:y_dart/y_dart')
external YInput yinput_json_array(
  ffi.Pointer<YInput> values,
  int len,
);

/// Function constructor used to create a JSON-like map `YInput` cell of other JSON-like key-value
/// pairs. These pairs are build from corresponding indexes of `keys` and `values`, which must have
/// the same specified length.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<
        YInput Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<YInput>,
            ffi.Uint32)>(
    symbol: 'yinput_json_map', assetId: 'package:y_dart/y_dart')
external YInput yinput_json_map(
  ffi.Pointer<ffi.Pointer<ffi.Char>> keys,
  ffi.Pointer<YInput> values,
  int len,
);

/// Function constructor used to create a nested `YArray` `YInput` cell prefilled with other
/// values of a given length. This function doesn't allocate any heap resources and doesn't release
/// any on its own, therefore its up to a caller to free resources once a structure is no longer
/// needed.
@ffi.Native<YInput Function(ffi.Pointer<YInput>, ffi.Uint32)>(
    symbol: 'yinput_yarray', assetId: 'package:y_dart/y_dart')
external YInput yinput_yarray(
  ffi.Pointer<YInput> values,
  int len,
);

/// Function constructor used to create a nested `YMap` `YInput` cell prefilled with other key-value
/// pairs. These pairs are build from corresponding indexes of `keys` and `values`, which must have
/// the same specified length.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<
    YInput Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<YInput>,
        ffi.Uint32)>(symbol: 'yinput_ymap', assetId: 'package:y_dart/y_dart')
external YInput yinput_ymap(
  ffi.Pointer<ffi.Pointer<ffi.Char>> keys,
  ffi.Pointer<YInput> values,
  int len,
);

/// Function constructor used to create a nested `YText` `YInput` cell prefilled with a specified
/// string, which must be a null-terminated UTF-8 character pointer.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'yinput_ytext', assetId: 'package:y_dart/y_dart')
external YInput yinput_ytext(
  ffi.Pointer<ffi.Char> str,
);

/// Function constructor used to create a nested `YXmlElement` `YInput` cell with a specified
/// tag name, which must be a null-terminated UTF-8 character pointer.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'yinput_yxmlelem', assetId: 'package:y_dart/y_dart')
external YInput yinput_yxmlelem(
  ffi.Pointer<ffi.Char> name,
);

/// Function constructor used to create a nested `YXmlText` `YInput` cell prefilled with a specified
/// string, which must be a null-terminated UTF-8 character pointer.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'yinput_yxmltext', assetId: 'package:y_dart/y_dart')
external YInput yinput_yxmltext(
  ffi.Pointer<ffi.Char> str,
);

/// Function constructor used to create a nested `YDoc` `YInput` cell.
///
/// This function doesn't allocate any heap resources and doesn't release any on its own, therefore
/// its up to a caller to free resources once a structure is no longer needed.
@ffi.Native<YInput Function(ffi.Pointer<YDoc>)>(
    symbol: 'yinput_ydoc', assetId: 'package:y_dart/y_dart')
external YInput yinput_ydoc(
  ffi.Pointer<YDoc> doc,
);

/// Function constructor used to create a string `YInput` cell with weak reference to another
/// element(s) living inside of the same document.
@ffi.Native<YInput Function(ffi.Pointer<Weak>)>(
    symbol: 'yinput_weak', assetId: 'package:y_dart/y_dart')
external YInput yinput_weak(
  ffi.Pointer<Weak> weak,
);

/// Attempts to read the value for a given `YOutput` pointer as a `YDocRef` reference to a nested
/// document.
@ffi.Native<ffi.Pointer<YDoc> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_ydoc', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDoc> youtput_read_ydoc(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a boolean flag, which can be either
/// `1` for truthy case and `0` otherwise. Returns a null pointer in case when a value stored under
/// current `YOutput` cell is not of a boolean type.
@ffi.Native<ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_bool', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Uint8> youtput_read_bool(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a 64-bit floating point number.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a floating point number.
@ffi.Native<ffi.Pointer<ffi.Double> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_float', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Double> youtput_read_float(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a 64-bit signed integer.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a signed integer.
@ffi.Native<ffi.Pointer<ffi.Int64> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_long', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Int64> youtput_read_long(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a null-terminated UTF-8 encoded
/// string.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a string. Underlying string is released automatically as part of [youtput_destroy]
/// destructor.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> youtput_read_string(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a binary payload (which length is
/// stored within `len` filed of a cell itself).
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a binary type. Underlying binary is released automatically as part of [youtput_destroy]
/// destructor.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_binary', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> youtput_read_binary(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a JSON-like array of `YOutput`
/// values (which length is stored within `len` filed of a cell itself).
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a JSON-like array. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<YOutput> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_json_array', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> youtput_read_json_array(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as a JSON-like map of key-value entries
/// (which length is stored within `len` filed of a cell itself).
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not a JSON-like map. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<YMapEntry> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_json_map', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YMapEntry> youtput_read_json_map(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YArray`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YArray`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_yarray', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_yarray(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YXmlElement`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YXmlElement`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_yxmlelem', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_yxmlelem(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YMap`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YMap`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_ymap', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_ymap(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YText`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YText`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_ytext', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_ytext(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YXmlText`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YXmlText`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_yxmltext', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_yxmltext(
  ffi.Pointer<YOutput> val,
);

/// Attempts to read the value for a given `YOutput` pointer as an `YWeakRef`.
///
/// Returns a null pointer in case when a value stored under current `YOutput` cell
/// is not an `YWeakRef`. Underlying heap resources are released automatically as part of
/// [youtput_destroy] destructor.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YOutput>)>(
    symbol: 'youtput_read_yweak', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> youtput_read_yweak(
  ffi.Pointer<YOutput> val,
);

/// Unsubscribe callback from the oberver event it was previously subscribed to.
@ffi.Native<ffi.Void Function(ffi.Pointer<YSubscription>)>(
    symbol: 'yunobserve', assetId: 'package:y_dart/y_dart')
external void yunobserve(
  ffi.Pointer<YSubscription> subscription,
);

/// Subscribes a given callback function `cb` to changes made by this `YText` instance. Callbacks
/// are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YTextEvent>)>>)>(
    symbol: 'ytext_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ytext_observe(
  ffi.Pointer<Branch> txt,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YTextEvent>)>>
      cb,
);

/// Subscribes a given callback function `cb` to changes made by this `YMap` instance. Callbacks
/// are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YMapEvent>)>>)>(
    symbol: 'ymap_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> ymap_observe(
  ffi.Pointer<Branch> map,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<YMapEvent>)>>
      cb,
);

/// Subscribes a given callback function `cb` to changes made by this `YArray` instance. Callbacks
/// are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YArrayEvent>)>>)>(
    symbol: 'yarray_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yarray_observe(
  ffi.Pointer<Branch> array,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YArrayEvent>)>>
      cb,
);

/// Subscribes a given callback function `cb` to changes made by this `YXmlElement` instance.
/// Callbacks are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YXmlEvent>)>>)>(
    symbol: 'yxmlelem_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yxmlelem_observe(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<YXmlEvent>)>>
      cb,
);

/// Subscribes a given callback function `cb` to changes made by this `YXmlText` instance. Callbacks
/// are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YXmlTextEvent>)>>)>(
    symbol: 'yxmltext_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yxmltext_observe(
  ffi.Pointer<Branch> xml,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YXmlTextEvent>)>>
      cb,
);

/// Subscribes a given callback function `cb` to changes made by this shared type instance as well
/// as all nested shared types living within it. Callbacks are triggered whenever a
/// `ytransaction_commit` is called.
///
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
                        ffi.Pointer<YEvent>)>>)>(
    symbol: 'yobserve_deep', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yobserve_deep(
  ffi.Pointer<Branch> ytype,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Pointer<YEvent>)>>
      cb,
);

/// Returns a pointer to a shared collection, which triggered passed event `e`.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YTextEvent>)>(
    symbol: 'ytext_event_target', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ytext_event_target(
  ffi.Pointer<YTextEvent> e,
);

/// Returns a pointer to a shared collection, which triggered passed event `e`.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YArrayEvent>)>(
    symbol: 'yarray_event_target', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yarray_event_target(
  ffi.Pointer<YArrayEvent> e,
);

/// Returns a pointer to a shared collection, which triggered passed event `e`.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YMapEvent>)>(
    symbol: 'ymap_event_target', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ymap_event_target(
  ffi.Pointer<YMapEvent> e,
);

/// Returns a pointer to a shared collection, which triggered passed event `e`.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YXmlEvent>)>(
    symbol: 'yxmlelem_event_target', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmlelem_event_target(
  ffi.Pointer<YXmlEvent> e,
);

/// Returns a pointer to a shared collection, which triggered passed event `e`.
@ffi.Native<ffi.Pointer<Branch> Function(ffi.Pointer<YXmlTextEvent>)>(
    symbol: 'yxmltext_event_target', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> yxmltext_event_target(
  ffi.Pointer<YXmlTextEvent> e,
);

/// Returns a path from a root type down to a current shared collection (which can be obtained using
/// `ytext_event_target` function). It can consist of either integer indexes (used by sequence
/// components) of *char keys (used by map components). `len` output parameter is used to provide
/// information about length of the path.
///
/// Path returned this way should be eventually released using `ypath_destroy`.
@ffi.Native<
        ffi.Pointer<YPathSegment> Function(
            ffi.Pointer<YTextEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytext_event_path', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPathSegment> ytext_event_path(
  ffi.Pointer<YTextEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a path from a root type down to a current shared collection (which can be obtained using
/// `ymap_event_target` function). It can consist of either integer indexes (used by sequence
/// components) of *char keys (used by map components). `len` output parameter is used to provide
/// information about length of the path.
///
/// Path returned this way should be eventually released using `ypath_destroy`.
@ffi.Native<
        ffi.Pointer<YPathSegment> Function(
            ffi.Pointer<YMapEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ymap_event_path', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPathSegment> ymap_event_path(
  ffi.Pointer<YMapEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a path from a root type down to a current shared collection (which can be obtained using
/// `yxmlelem_event_path` function). It can consist of either integer indexes (used by sequence
/// components) of *char keys (used by map components). `len` output parameter is used to provide
/// information about length of the path.
///
/// Path returned this way should be eventually released using `ypath_destroy`.
@ffi.Native<
        ffi.Pointer<YPathSegment> Function(
            ffi.Pointer<YXmlEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmlelem_event_path', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPathSegment> yxmlelem_event_path(
  ffi.Pointer<YXmlEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a path from a root type down to a current shared collection (which can be obtained using
/// `yxmltext_event_path` function). It can consist of either integer indexes (used by sequence
/// components) of *char keys (used by map components). `len` output parameter is used to provide
/// information about length of the path.
///
/// Path returned this way should be eventually released using `ypath_destroy`.
@ffi.Native<
        ffi.Pointer<YPathSegment> Function(
            ffi.Pointer<YXmlTextEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmltext_event_path', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPathSegment> yxmltext_event_path(
  ffi.Pointer<YXmlTextEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a path from a root type down to a current shared collection (which can be obtained using
/// `yarray_event_target` function). It can consist of either integer indexes (used by sequence
/// components) of *char keys (used by map components). `len` output parameter is used to provide
/// information about length of the path.
///
/// Path returned this way should be eventually released using `ypath_destroy`.
@ffi.Native<
        ffi.Pointer<YPathSegment> Function(
            ffi.Pointer<YArrayEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yarray_event_path', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YPathSegment> yarray_event_path(
  ffi.Pointer<YArrayEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Releases allocated memory used by objects returned from path accessor functions of shared type
/// events.
@ffi.Native<ffi.Void Function(ffi.Pointer<YPathSegment>, ffi.Uint32)>(
    symbol: 'ypath_destroy', assetId: 'package:y_dart/y_dart')
external void ypath_destroy(
  ffi.Pointer<YPathSegment> path,
  int len,
);

/// Returns a sequence of changes produced by sequence component of shared collections (such as
/// `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
/// provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_delta_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YDeltaOut> Function(
            ffi.Pointer<YTextEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ytext_event_delta', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDeltaOut> ytext_event_delta(
  ffi.Pointer<YTextEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a sequence of changes produced by sequence component of shared collections (such as
/// `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
/// provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_delta_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YDeltaOut> Function(
            ffi.Pointer<YXmlTextEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmltext_event_delta', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YDeltaOut> yxmltext_event_delta(
  ffi.Pointer<YXmlTextEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a sequence of changes produced by sequence component of shared collections (such as
/// `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
/// provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_delta_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YEventChange> Function(
            ffi.Pointer<YArrayEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yarray_event_delta', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YEventChange> yarray_event_delta(
  ffi.Pointer<YArrayEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a sequence of changes produced by sequence component of shared collections (such as
/// `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
/// provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_delta_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YEventChange> Function(
            ffi.Pointer<YXmlEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmlelem_event_delta', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YEventChange> yxmlelem_event_delta(
  ffi.Pointer<YXmlEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Releases memory allocated by the object returned from `yevent_delta` function.
@ffi.Native<ffi.Void Function(ffi.Pointer<YDeltaOut>, ffi.Uint32)>(
    symbol: 'ytext_delta_destroy', assetId: 'package:y_dart/y_dart')
external void ytext_delta_destroy(
  ffi.Pointer<YDeltaOut> delta,
  int len,
);

/// Releases memory allocated by the object returned from `yevent_delta` function.
@ffi.Native<ffi.Void Function(ffi.Pointer<YEventChange>, ffi.Uint32)>(
    symbol: 'yevent_delta_destroy', assetId: 'package:y_dart/y_dart')
external void yevent_delta_destroy(
  ffi.Pointer<YEventChange> delta,
  int len,
);

/// Returns a sequence of changes produced by map component of shared collections (such as
/// `YMap` and `YXmlText`/`YXmlElement` attribute changes). `len` output parameter is used to
/// provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_keys_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YEventKeyChange> Function(
            ffi.Pointer<YMapEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ymap_event_keys', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YEventKeyChange> ymap_event_keys(
  ffi.Pointer<YMapEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a sequence of changes produced by map component of shared collections.
/// `len` output parameter is used to provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_keys_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YEventKeyChange> Function(
            ffi.Pointer<YXmlEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmlelem_event_keys', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YEventKeyChange> yxmlelem_event_keys(
  ffi.Pointer<YXmlEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Returns a sequence of changes produced by map component of shared collections.
/// `len` output parameter is used to provide information about number of changes produced.
///
/// Delta returned from this function should eventually be released using `yevent_keys_destroy`
/// function.
@ffi.Native<
        ffi.Pointer<YEventKeyChange> Function(
            ffi.Pointer<YXmlTextEvent>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'yxmltext_event_keys', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YEventKeyChange> yxmltext_event_keys(
  ffi.Pointer<YXmlTextEvent> e,
  ffi.Pointer<ffi.Uint32> len,
);

/// Releases memory allocated by the object returned from `yxml_event_keys` and `ymap_event_keys`
/// functions.
@ffi.Native<ffi.Void Function(ffi.Pointer<YEventKeyChange>, ffi.Uint32)>(
    symbol: 'yevent_keys_destroy', assetId: 'package:y_dart/y_dart')
external void yevent_keys_destroy(
  ffi.Pointer<YEventKeyChange> keys,
  int len,
);

/// Creates a new instance of undo manager bound to a current `doc`. It can be used to track
/// specific shared refs via `yundo_manager_add_scope` and updates coming from specific origin
/// - like ability to undo/redo operations originating only at the local peer - by using
/// `yundo_manager_add_origin`.
///
/// This object can be deallocated via `yundo_manager_destroy`.
@ffi.Native<
        ffi.Pointer<YUndoManager> Function(
            ffi.Pointer<YDoc>, ffi.Pointer<YUndoManagerOptions>)>(
    symbol: 'yundo_manager', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YUndoManager> yundo_manager(
  ffi.Pointer<YDoc> doc,
  ffi.Pointer<YUndoManagerOptions> options,
);

/// Deallocated undo manager instance created via `yundo_manager`.
@ffi.Native<ffi.Void Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_destroy', assetId: 'package:y_dart/y_dart')
external void yundo_manager_destroy(
  ffi.Pointer<YUndoManager> mgr,
);

/// Adds an origin to be tracked by current undo manager. This way only changes made within context
/// of transactions created with specific origin will be subjects of undo/redo operations. This is
/// useful when you want to be able to revert changed done by specific user without reverting
/// changes made by other users that were applied in the meantime.
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<YUndoManager>, ffi.Uint32, ffi.Pointer<ffi.Char>)>(
    symbol: 'yundo_manager_add_origin', assetId: 'package:y_dart/y_dart')
external void yundo_manager_add_origin(
  ffi.Pointer<YUndoManager> mgr,
  int origin_len,
  ffi.Pointer<ffi.Char> origin,
);

/// Removes an origin previously added to undo manager via `yundo_manager_add_origin`.
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<YUndoManager>, ffi.Uint32, ffi.Pointer<ffi.Char>)>(
    symbol: 'yundo_manager_remove_origin', assetId: 'package:y_dart/y_dart')
external void yundo_manager_remove_origin(
  ffi.Pointer<YUndoManager> mgr,
  int origin_len,
  ffi.Pointer<ffi.Char> origin,
);

/// Add specific shared type to be tracked by this instance of an undo manager.
@ffi.Native<ffi.Void Function(ffi.Pointer<YUndoManager>, ffi.Pointer<Branch>)>(
    symbol: 'yundo_manager_add_scope', assetId: 'package:y_dart/y_dart')
external void yundo_manager_add_scope(
  ffi.Pointer<YUndoManager> mgr,
  ffi.Pointer<Branch> ytype,
);

/// Removes all the undo/redo stack changes tracked by current undo manager. This also cleans up
/// all the items that couldn't be deallocated / garbage collected for the sake of possible
/// undo/redo operations.
///
/// Keep in mind that this function call requires that underlying document store is not concurrently
/// modified by other read-write transaction. This is done by acquiring the read-only transaction
/// itself. If such transaction could be acquired (because of another read-write transaction is in
/// progress, this function will hold current thread until acquisition is possible.
@ffi.Native<ffi.Void Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_clear', assetId: 'package:y_dart/y_dart')
external void yundo_manager_clear(
  ffi.Pointer<YUndoManager> mgr,
);

/// Cuts off tracked changes, producing a new stack item on undo stack.
///
/// By default, undo manager gathers undergoing changes together into undo stack items on periodic
/// basis (defined by `YUndoManagerOptions.capture_timeout_millis`). By calling this function, we're
/// explicitly creating a new stack item will all the changes registered since last stack item was
/// created.
@ffi.Native<ffi.Void Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_stop', assetId: 'package:y_dart/y_dart')
external void yundo_manager_stop(
  ffi.Pointer<YUndoManager> mgr,
);

/// Performs an undo operations, reverting all the changes defined by the last undo stack item.
/// These changes can be then reapplied again by calling `yundo_manager_redo` function.
///
/// Returns `Y_TRUE` if successfully managed to do an undo operation.
/// Returns `Y_FALSE` if undo stack was empty or if undo couldn't be performed (because another
/// transaction is in progress).
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_undo', assetId: 'package:y_dart/y_dart')
external int yundo_manager_undo(
  ffi.Pointer<YUndoManager> mgr,
);

/// Performs a redo operations, reapplying changes undone by `yundo_manager_undo` operation.
///
/// Returns `Y_TRUE` if successfully managed to do a redo operation.
/// Returns `Y_FALSE` if redo stack was empty or if redo couldn't be performed (because another
/// transaction is in progress).
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_redo', assetId: 'package:y_dart/y_dart')
external int yundo_manager_redo(
  ffi.Pointer<YUndoManager> mgr,
);

/// Returns number of elements stored on undo stack.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_undo_stack_len', assetId: 'package:y_dart/y_dart')
external int yundo_manager_undo_stack_len(
  ffi.Pointer<YUndoManager> mgr,
);

/// Returns number of elements stored on redo stack.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<YUndoManager>)>(
    symbol: 'yundo_manager_redo_stack_len', assetId: 'package:y_dart/y_dart')
external int yundo_manager_redo_stack_len(
  ffi.Pointer<YUndoManager> mgr,
);

/// Subscribes a `callback` function pointer to a given undo manager event. This event will be
/// triggered every time a new undo/redo stack item is added.
///
/// Returns a subscription pointer that can be used to cancel current callback registration via
/// `yunobserve`.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YUndoManager>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YUndoEvent>)>>)>(
    symbol: 'yundo_manager_observe_added', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yundo_manager_observe_added(
  ffi.Pointer<YUndoManager> mgr,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YUndoEvent>)>>
      callback,
);

/// Subscribes a `callback` function pointer to a given undo manager event. This event will be
/// triggered every time a undo/redo operation was called.
///
/// Returns a subscription pointer that can be used to cancel current callback registration via
/// `yunobserve`.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<YUndoManager>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YUndoEvent>)>>)>(
    symbol: 'yundo_manager_observe_popped', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yundo_manager_observe_popped(
  ffi.Pointer<YUndoManager> mgr,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YUndoEvent>)>>
      callback,
);

/// Returns a value informing what kind of Yrs shared collection given `branch` represents.
/// Returns either 0 when `branch` is null or one of values: `Y_ARRAY`, `Y_TEXT`, `Y_MAP`,
/// `Y_XML_ELEM`, `Y_XML_TEXT`.
@ffi.Native<ffi.Int8 Function(ffi.Pointer<Branch>)>(
    symbol: 'ytype_kind', assetId: 'package:y_dart/y_dart')
external int ytype_kind(
  ffi.Pointer<Branch> branch,
);

/// Releases resources allocated by `YStickyIndex` pointers.
@ffi.Native<ffi.Void Function(ffi.Pointer<YStickyIndex>)>(
    symbol: 'ysticky_index_destroy', assetId: 'package:y_dart/y_dart')
external void ysticky_index_destroy(
  ffi.Pointer<YStickyIndex> pos,
);

/// Returns association of current `YStickyIndex`.
/// If association is **after** the referenced inserted character, returned number will be >= 0.
/// If association is **before** the referenced inserted character, returned number will be < 0.
@ffi.Native<ffi.Int8 Function(ffi.Pointer<YStickyIndex>)>(
    symbol: 'ysticky_index_assoc', assetId: 'package:y_dart/y_dart')
external int ysticky_index_assoc(
  ffi.Pointer<YStickyIndex> pos,
);

/// Retrieves a `YStickyIndex` corresponding to a given human-readable `index` pointing into
/// the shared y-type `branch`. Unlike standard indexes sticky one enables to track
/// the location inside of a shared y-types, even in the face of concurrent updates.
///
/// If association is >= 0, the resulting position will point to location **after** the referenced index.
/// If association is < 0, the resulting position will point to location **before** the referenced index.
@ffi.Native<
        ffi.Pointer<YStickyIndex> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Uint32, ffi.Int8)>(
    symbol: 'ysticky_index_from_index', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YStickyIndex> ysticky_index_from_index(
  ffi.Pointer<Branch> branch,
  ffi.Pointer<YTransaction> txn,
  int index,
  int assoc,
);

/// Serializes `YStickyIndex` into binary representation. `len` parameter is updated with byte
/// length of the generated binary. Returned binary can be free'd using `ybinary_destroy`.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<YStickyIndex>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ysticky_index_encode', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ysticky_index_encode(
  ffi.Pointer<YStickyIndex> pos,
  ffi.Pointer<ffi.Uint32> len,
);

/// Deserializes `YStickyIndex` from the payload previously serialized using `ysticky_index_encode`.
@ffi.Native<
        ffi.Pointer<YStickyIndex> Function(ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'ysticky_index_decode', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YStickyIndex> ysticky_index_decode(
  ffi.Pointer<ffi.Char> binary,
  int len,
);

/// Given `YStickyIndex` and transaction reference, if computes a human-readable index in a
/// context of the referenced shared y-type.
///
/// `out_branch` is getting assigned with a corresponding shared y-type reference.
/// `out_index` will be used to store computed human-readable index.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<YStickyIndex>, ffi.Pointer<YTransaction>,
            ffi.Pointer<ffi.Pointer<Branch>>, ffi.Pointer<ffi.Uint32>)>(
    symbol: 'ysticky_index_read', assetId: 'package:y_dart/y_dart')
external void ysticky_index_read(
  ffi.Pointer<YStickyIndex> pos,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Pointer<Branch>> out_branch,
  ffi.Pointer<ffi.Uint32> out_index,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Weak>)>(
    symbol: 'yweak_destroy', assetId: 'package:y_dart/y_dart')
external void yweak_destroy(
  ffi.Pointer<Weak> weak,
);

@ffi.Native<
        ffi.Pointer<YOutput> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yweak_deref', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yweak_deref(
  ffi.Pointer<Branch> map_link,
  ffi.Pointer<YTransaction> txn,
);

@ffi.Native<
        ffi.Pointer<YWeakIter> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yweak_iter', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YWeakIter> yweak_iter(
  ffi.Pointer<Branch> array_link,
  ffi.Pointer<YTransaction> txn,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<YWeakIter>)>(
    symbol: 'yweak_iter_destroy', assetId: 'package:y_dart/y_dart')
external void yweak_iter_destroy(
  ffi.Pointer<YWeakIter> iter,
);

@ffi.Native<ffi.Pointer<YOutput> Function(ffi.Pointer<YWeakIter>)>(
    symbol: 'yweak_iter_next', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YOutput> yweak_iter_next(
  ffi.Pointer<YWeakIter> iter,
);

@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yweak_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yweak_string(
  ffi.Pointer<Branch> text_link,
  ffi.Pointer<YTransaction> txn,
);

@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'yweak_xml_string', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> yweak_xml_string(
  ffi.Pointer<Branch> xml_text_link,
  ffi.Pointer<YTransaction> txn,
);

/// Subscribes a given callback function `cb` to changes made by this `YText` instance. Callbacks
/// are triggered whenever a `ytransaction_commit` is called.
/// Returns a subscription ID which can be then used to unsubscribe this callback by using
/// `yunobserve` function.
@ffi.Native<
        ffi.Pointer<YSubscription> Function(
            ffi.Pointer<Branch>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void>, ffi.Pointer<YWeakLinkEvent>)>>)>(
    symbol: 'yweak_observe', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<YSubscription> yweak_observe(
  ffi.Pointer<Branch> weak,
  ffi.Pointer<ffi.Void> state,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<YWeakLinkEvent>)>>
      cb,
);

@ffi.Native<
        ffi.Pointer<Weak> Function(ffi.Pointer<Branch>,
            ffi.Pointer<YTransaction>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ymap_link', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Weak> ymap_link(
  ffi.Pointer<Branch> map,
  ffi.Pointer<YTransaction> txn,
  ffi.Pointer<ffi.Char> key,
);

@ffi.Native<
    ffi.Pointer<Weak> Function(
        ffi.Pointer<Branch>,
        ffi.Pointer<YTransaction>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Int8,
        ffi.Int8)>(symbol: 'ytext_quote', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Weak> ytext_quote(
  ffi.Pointer<Branch> text,
  ffi.Pointer<YTransaction> txn,
  int start_index,
  int end_index,
  int start_exclusive,
  int end_exclusive,
);

@ffi.Native<
    ffi.Pointer<Weak> Function(
        ffi.Pointer<Branch>,
        ffi.Pointer<YTransaction>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Int8,
        ffi.Int8)>(symbol: 'yarray_quote', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Weak> yarray_quote(
  ffi.Pointer<Branch> array,
  ffi.Pointer<YTransaction> txn,
  int start_index,
  int end_index,
  int start_exclusive,
  int end_exclusive,
);

/// Returns a logical identifier for a given shared collection. That collection must be alive at
/// the moment of function call.
@ffi.Native<YBranchId Function(ffi.Pointer<Branch>)>(
    symbol: 'ybranch_id', assetId: 'package:y_dart/y_dart')
external YBranchId ybranch_id(
  ffi.Pointer<Branch> branch,
);

/// Given a logical identifier, returns a physical pointer to a shared collection.
/// Returns null if collection was not found - either because it was not defined or not synchronized
/// yet.
/// Returned pointer may still point to deleted collection. In such case a subsequent `ybranch_alive`
/// function call is required.
@ffi.Native<
        ffi.Pointer<Branch> Function(
            ffi.Pointer<YBranchId>, ffi.Pointer<YTransaction>)>(
    symbol: 'ybranch_get', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<Branch> ybranch_get(
  ffi.Pointer<YBranchId> branch_id,
  ffi.Pointer<YTransaction> txn,
);

/// Check if current branch is still alive (returns `Y_TRUE`, otherwise `Y_FALSE`).
/// If it was deleted, this branch pointer is no longer a valid pointer and cannot be used to
/// execute any functions using it.
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<Branch>)>(
    symbol: 'ybranch_alive', assetId: 'package:y_dart/y_dart')
external int ybranch_alive(
  ffi.Pointer<Branch> branch,
);

/// Returns a UTF-8 encoded, NULL-terminated JSON string representation of the current branch
/// contents. Once no longer needed, this string must be explicitly deallocated by user using
/// `ystring_destroy`.
///
/// If branch type couldn't be resolved (which usually happens for root-level types that were not
/// initialized locally) or doesn't have JSON representation a NULL pointer can be returned.
@ffi.Native<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<Branch>, ffi.Pointer<YTransaction>)>(
    symbol: 'ybranch_json', assetId: 'package:y_dart/y_dart')
external ffi.Pointer<ffi.Char> ybranch_json(
  ffi.Pointer<Branch> branch,
  ffi.Pointer<YTransaction> txn,
);

/// A Yrs document type. Documents are most important units of collaborative resources management.
/// All shared collections live within a scope of their corresponding documents. All updates are
/// generated on per document basis (rather than individual shared type). All operations on shared
/// collections happen via `YTransaction`, which lifetime is also bound to a document.
///
/// Document manages so called root types, which are top-level shared types definitions (as opposed
/// to recursively nested types).
final class YDoc extends ffi.Opaque {}

/// A common shared data type. All Yrs instances can be refered to using this data type (use
/// `ytype_kind` function if a specific type needs to be determined). Branch pointers are passed
/// over type-specific functions like `ytext_insert`, `yarray_insert` or `ymap_insert` to perform
/// a specific shared type operations.
///
/// Using write methods of different shared types (eg. `ytext_insert` and `yarray_insert`) over
/// the same branch may result in undefined behavior.
final class Branch extends ffi.Opaque {}

final class Transaction extends ffi.Opaque {}

final class TransactionMut extends ffi.Opaque {}

/// Iterator structure used by weak link unquote.
final class YWeakIter extends ffi.Opaque {}

/// Iterator structure used by shared array data type.
final class YArrayIter extends ffi.Opaque {}

/// Iterator structure used by shared map data type. Map iterators are unordered - there's no
/// specific order in which map entries will be returned during consecutive iterator calls.
final class YMapIter extends ffi.Opaque {}

/// Iterator structure used by XML nodes (elements and text) to iterate over node's attributes.
/// Attribute iterators are unordered - there's no specific order in which map entries will be
/// returned during consecutive iterator calls.
final class YXmlAttrIter extends ffi.Opaque {}

/// Iterator used to traverse over the complex nested tree structure of a XML node. XML node
/// iterator walks only over `YXmlElement` and `YXmlText` nodes. It does so in ordered manner (using
/// the order in which children are ordered within their parent nodes) and using **depth-first**
/// traverse.
final class YXmlTreeWalker extends ffi.Opaque {}

final class YUndoManager extends ffi.Opaque {}

final class LinkSource extends ffi.Opaque {}

final class Unquote extends ffi.Opaque {}

final class StickyIndex extends ffi.Opaque {}

final class YSubscription extends ffi.Opaque {}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// [XSI] The type idtype_t shall be defined as an enumeration type whose
/// possible values shall include at least P_ALL, P_PID, and P_PGID.
abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

final class __darwin_i386_thread_state extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __eax;

  @ffi.UnsignedInt()
  external int __ebx;

  @ffi.UnsignedInt()
  external int __ecx;

  @ffi.UnsignedInt()
  external int __edx;

  @ffi.UnsignedInt()
  external int __edi;

  @ffi.UnsignedInt()
  external int __esi;

  @ffi.UnsignedInt()
  external int __ebp;

  @ffi.UnsignedInt()
  external int __esp;

  @ffi.UnsignedInt()
  external int __ss;

  @ffi.UnsignedInt()
  external int __eflags;

  @ffi.UnsignedInt()
  external int __eip;

  @ffi.UnsignedInt()
  external int __cs;

  @ffi.UnsignedInt()
  external int __ds;

  @ffi.UnsignedInt()
  external int __es;

  @ffi.UnsignedInt()
  external int __fs;

  @ffi.UnsignedInt()
  external int __gs;
}

final class __darwin_fp_control extends ffi.Opaque {}

final class __darwin_fp_status extends ffi.Opaque {}

final class __darwin_mmst_reg extends ffi.Struct {
  @ffi.Array.multi([10])
  external ffi.Array<ffi.Char> __mmst_reg;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Char> __mmst_rsrv;
}

final class __darwin_xmm_reg extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __xmm_reg;
}

final class __darwin_ymm_reg extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __ymm_reg;
}

final class __darwin_zmm_reg extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> __zmm_reg;
}

final class __darwin_opmask_reg extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opmask_reg;
}

final class __darwin_i386_float_state extends ffi.Opaque {}

final class __darwin_i386_avx_state extends ffi.Opaque {}

final class __darwin_i386_avx512_state extends ffi.Opaque {}

final class __darwin_i386_exception_state extends ffi.Struct {
  @__uint16_t()
  external int __trapno;

  @__uint16_t()
  external int __cpu;

  @__uint32_t()
  external int __err;

  @__uint32_t()
  external int __faultvaddr;
}

typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class __darwin_x86_debug_state32 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __dr0;

  @ffi.UnsignedInt()
  external int __dr1;

  @ffi.UnsignedInt()
  external int __dr2;

  @ffi.UnsignedInt()
  external int __dr3;

  @ffi.UnsignedInt()
  external int __dr4;

  @ffi.UnsignedInt()
  external int __dr5;

  @ffi.UnsignedInt()
  external int __dr6;

  @ffi.UnsignedInt()
  external int __dr7;
}

final class __x86_instruction_state extends ffi.Struct {
  @ffi.Int()
  external int __insn_stream_valid_bytes;

  @ffi.Int()
  external int __insn_offset;

  /// non-zero when the cacheline that includes the insn_offset
  /// is replaced in the insn_bytes array due to a mismatch
  /// detected when comparing it with the same cacheline in memory
  @ffi.Int()
  external int __out_of_synch;

  @ffi.Array.multi([2380])
  external ffi.Array<__uint8_t> __insn_bytes;

  @ffi.Array.multi([64])
  external ffi.Array<__uint8_t> __insn_cacheline;
}

typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;

final class __last_branch_record extends ffi.Opaque {}

final class __last_branch_state extends ffi.Opaque {}

final class __x86_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __darwin_x86_thread_state64 extends ffi.Struct {
  @__uint64_t()
  external int __rax;

  @__uint64_t()
  external int __rbx;

  @__uint64_t()
  external int __rcx;

  @__uint64_t()
  external int __rdx;

  @__uint64_t()
  external int __rdi;

  @__uint64_t()
  external int __rsi;

  @__uint64_t()
  external int __rbp;

  @__uint64_t()
  external int __rsp;

  @__uint64_t()
  external int __r8;

  @__uint64_t()
  external int __r9;

  @__uint64_t()
  external int __r10;

  @__uint64_t()
  external int __r11;

  @__uint64_t()
  external int __r12;

  @__uint64_t()
  external int __r13;

  @__uint64_t()
  external int __r14;

  @__uint64_t()
  external int __r15;

  @__uint64_t()
  external int __rip;

  @__uint64_t()
  external int __rflags;

  @__uint64_t()
  external int __cs;

  @__uint64_t()
  external int __fs;

  @__uint64_t()
  external int __gs;
}

typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;

final class __darwin_x86_thread_full_state64 extends ffi.Struct {
  external __darwin_x86_thread_state64 __ss64;

  @__uint64_t()
  external int __ds;

  @__uint64_t()
  external int __es;

  @__uint64_t()
  external int __ss;

  @__uint64_t()
  external int __gsbase;
}

final class __darwin_x86_float_state64 extends ffi.Opaque {}

final class __darwin_x86_avx_state64 extends ffi.Opaque {}

final class __darwin_x86_avx512_state64 extends ffi.Opaque {}

final class __darwin_x86_exception_state64 extends ffi.Struct {
  @__uint16_t()
  external int __trapno;

  @__uint16_t()
  external int __cpu;

  @__uint32_t()
  external int __err;

  @__uint64_t()
  external int __faultvaddr;
}

final class __darwin_x86_debug_state64 extends ffi.Struct {
  @__uint64_t()
  external int __dr0;

  @__uint64_t()
  external int __dr1;

  @__uint64_t()
  external int __dr2;

  @__uint64_t()
  external int __dr3;

  @__uint64_t()
  external int __dr4;

  @__uint64_t()
  external int __dr5;

  @__uint64_t()
  external int __dr6;

  @__uint64_t()
  external int __dr7;
}

final class __darwin_x86_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Opaque {}

final class __darwin_mcontext_avx32 extends ffi.Opaque {}

final class __darwin_mcontext_avx512_32 extends ffi.Opaque {}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_mcontext64_full extends ffi.Opaque {}

final class __darwin_mcontext_avx64 extends ffi.Opaque {}

final class __darwin_mcontext_avx64_full extends ffi.Opaque {}

final class __darwin_mcontext_avx512_64 extends ffi.Opaque {}

final class __darwin_mcontext_avx512_64_full extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  /// signal stack base
  external ffi.Pointer<ffi.Void> ss_sp;

  /// signal stack length
  @__darwin_size_t()
  external int ss_size;

  /// SA_DISABLE and/or SA_ONSTACK
  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  /// signal mask used by this context
  @__darwin_sigset_t()
  external int uc_sigmask;

  /// stack used by this context
  external __darwin_sigaltstack uc_stack;

  /// pointer to resuming context
  external ffi.Pointer<__darwin_ucontext> uc_link;

  /// size of the machine context passed in
  @__darwin_size_t()
  external int uc_mcsize;

  /// pointer to machine specific context
  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  /// Members as suggested by Annex C of POSIX 1003.1b.
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  /// Notification type
  @ffi.Int()
  external int sigev_notify;

  /// Signal number
  @ffi.Int()
  external int sigev_signo;

  /// Signal value
  external sigval sigev_value;

  /// Notification function
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  /// Notification attributes
  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  /// signal number
  @ffi.Int()
  external int si_signo;

  /// errno association
  @ffi.Int()
  external int si_errno;

  /// signal code
  @ffi.Int()
  external int si_code;

  /// sending process
  @pid_t()
  external int si_pid;

  /// sender's ruid
  @uid_t()
  external int si_uid;

  /// exit value
  @ffi.Int()
  external int si_status;

  /// faulting instruction
  external ffi.Pointer<ffi.Void> si_addr;

  /// signal value
  external sigval si_value;

  /// band event for SIGPOLL
  @ffi.Long()
  external int si_band;

  /// Reserved for Future Use
  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

/// union for signal handlers
final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

/// Signal vector template for Kernel user boundary
final class __sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

/// Signal vector "template" used in sigaction call.
final class sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

/// 4.3 compatibility:
/// Signal vector "template" used in sigvec call.
final class sigvec extends ffi.Struct {
  /// signal handler
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  /// signal mask to apply
  @ffi.Int()
  external int sv_mask;

  /// see signal options below
  @ffi.Int()
  external int sv_flags;
}

/// Structure used in sigstack call.
final class sigstack extends ffi.Struct {
  /// signal stack pointer
  external ffi.Pointer<ffi.Char> ss_sp;

  /// current status
  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  /// seconds
  @__darwin_time_t()
  external int tv_sec;

  /// and microseconds
  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_suseconds_t = __int32_t;

/// A structure representing an accounting of resource utilization.  The
/// address of an instance of this structure is the second parameter to
/// getrusage().
///
/// Note: All values other than ru_utime and ru_stime are implementaiton
/// defined and subject to change in a future release.  Their use
/// is discouraged for standards compliant programs.
final class rusage extends ffi.Struct {
  /// user time used (PL)
  external timeval ru_utime;

  /// system time used (PL)
  external timeval ru_stime;

  /// max resident set size (PL)
  @ffi.Long()
  external int ru_maxrss;

  /// integral shared memory size (NU)
  @ffi.Long()
  external int ru_ixrss;

  /// integral unshared data (NU)
  @ffi.Long()
  external int ru_idrss;

  /// integral unshared stack (NU)
  @ffi.Long()
  external int ru_isrss;

  /// page reclaims (NU)
  @ffi.Long()
  external int ru_minflt;

  /// page faults (NU)
  @ffi.Long()
  external int ru_majflt;

  /// swaps (NU)
  @ffi.Long()
  external int ru_nswap;

  /// block input operations (atomic)
  @ffi.Long()
  external int ru_inblock;

  /// block output operations (atomic)
  @ffi.Long()
  external int ru_oublock;

  /// messages sent (atomic)
  @ffi.Long()
  external int ru_msgsnd;

  /// messages received (atomic)
  @ffi.Long()
  external int ru_msgrcv;

  /// signals received (atomic)
  @ffi.Long()
  external int ru_nsignals;

  /// voluntary context switches (atomic)
  @ffi.Long()
  external int ru_nvcsw;

  /// involuntary "
  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

/// A structure representing a resource limit.  The address of an instance
/// of this structure is the second parameter to getrlimit()/setrlimit().
final class rlimit extends ffi.Struct {
  /// current (soft) limit
  @rlim_t()
  external int rlim_cur;

  /// maximum value for rlim_cur
  @rlim_t()
  external int rlim_max;
}

/// Resource limit type (low 63 bits, excluding the sign bit)
typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

/// Deprecated:
/// Structure of the information in the status word returned by wait4.
/// If w_stopval==_WSTOPPED, then the second structure describes
/// the information returned, else the first.
final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  /// quotient
  @ffi.Int()
  external int quot;

  /// remainder
  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  /// quotient
  @ffi.Long()
  external int quot;

  /// remainder
  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

/// !!!!!!!!!!!!!!!!!!!!! WARNING WARNING WARNING WARNING !!!!!!!!!!!!!!!!!!!!!
/// Typed Memory Operations and malloc_type_* functions constitute a private,
/// unstable interface.  Don't use it, don't depend on it.
/// !!!!!!!!!!!!!!!!!!!!! WARNING WARNING WARNING WARNING !!!!!!!!!!!!!!!!!!!!!
typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

/// <malloc/malloc.h>
typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;

final class TransactionInner extends ffi.Opaque {}

/// Configuration object used by `YDoc`.
final class YOptions extends ffi.Struct {
  /// Globally unique 53-bit integer assigned to corresponding document replica as its identifier.
  ///
  /// If two clients share the same `id` and will perform any updates, it will result in
  /// unrecoverable document state corruption. The same thing may happen if the client restored
  /// document state from snapshot, that didn't contain all of that clients updates that were sent
  /// to other peers.
  @ffi.Uint64()
  external int id;

  /// A NULL-able globally unique Uuid v4 compatible null-terminated string identifier
  /// of this document. If passed as NULL, a random Uuid will be generated instead.
  external ffi.Pointer<ffi.Char> guid;

  /// A NULL-able, UTF-8 encoded, null-terminated string of a collection that this document
  /// belongs to. It's used only by providers.
  external ffi.Pointer<ffi.Char> collection_id;

  /// Encoding used by text editing operations on this document. It's used to compute
  /// `YText`/`YXmlText` insertion offsets and text lengths. Either:
  ///
  /// - `Y_OFFSET_BYTES`
  /// - `Y_OFFSET_UTF16`
  @ffi.Uint8()
  external int encoding;

  /// Boolean flag used to determine if deleted blocks should be garbage collected or not
  /// during the transaction commits. Setting this value to 0 means GC will be performed.
  @ffi.Uint8()
  external int skip_gc;

  /// Boolean flag used to determine if subdocument should be loaded automatically.
  /// If this is a subdocument, remote peers will load the document as well automatically.
  @ffi.Uint8()
  external int auto_load;

  /// Boolean flag used to determine whether the document should be synced by the provider now.
  @ffi.Uint8()
  external int should_load;
}

final class YOutputContent extends ffi.Union {
  @ffi.Uint8()
  external int flag;

  @ffi.Double()
  external double num;

  @ffi.Int64()
  external int integer;

  external ffi.Pointer<ffi.Char> str;

  external ffi.Pointer<ffi.Char> buf;

  external ffi.Pointer<YOutput> array;

  external ffi.Pointer<YMapEntry> map;

  external ffi.Pointer<Branch> y_type;

  external ffi.Pointer<YDoc> y_doc;
}

/// An output value cell returned from yrs API methods. It describes a various types of data
/// supported by yrs shared data types.
///
/// Since `YOutput` instances are always created by calling the corresponding yrs API functions,
/// they eventually should be deallocated using [youtput_destroy] function.
final class YOutput extends ffi.Struct {
  /// Tag describing, which `value` type is being stored by this input cell. Can be one of:
  ///
  /// - [Y_JSON_BOOL] for boolean flags.
  /// - [Y_JSON_NUM] for 64-bit floating point numbers.
  /// - [Y_JSON_INT] for 64-bit signed integers.
  /// - [Y_JSON_STR] for null-terminated UTF-8 encoded strings.
  /// - [Y_JSON_BUF] for embedded binary data.
  /// - [Y_JSON_ARR] for arrays of JSON-like values.
  /// - [Y_JSON_MAP] for JSON-like objects build from key-value pairs.
  /// - [Y_JSON_NULL] for JSON-like null values.
  /// - [Y_JSON_UNDEF] for JSON-like undefined values.
  /// - [Y_TEXT] for pointers to `YText` data types.
  /// - [Y_ARRAY] for pointers to `YArray` data types.
  /// - [Y_MAP] for pointers to `YMap` data types.
  /// - [Y_XML_ELEM] for pointers to `YXmlElement` data types.
  /// - [Y_XML_TEXT] for pointers to `YXmlText` data types.
  /// - [Y_DOC] for pointers to nested `YDocRef` data types.
  @ffi.Int8()
  external int tag;

  /// Length of the contents stored by a current `YOutput` cell.
  ///
  /// For [Y_JSON_NULL] and [Y_JSON_UNDEF] its equal to `0`.
  ///
  /// For [Y_JSON_ARR], [Y_JSON_MAP] it describes a number of passed elements.
  ///
  /// For other types it's always equal to `1`.
  @ffi.Uint32()
  external int len;

  /// Union struct which contains a content corresponding to a provided `tag` field.
  external YOutputContent value;
}

/// A structure representing single key-value entry of a map output (used by either
/// embedded JSON-like maps or YMaps).
final class YMapEntry extends ffi.Struct {
  /// Null-terminated string representing an entry's key component. Encoded as UTF-8.
  external ffi.Pointer<ffi.Char> key;

  /// A `YOutput` value representing containing variadic content that can be stored withing map's
  /// entry.
  external ffi.Pointer<YOutput> value;
}

/// A structure representing single attribute of an either `YXmlElement` or `YXmlText` instance.
/// It consists of attribute name and string, both of which are null-terminated UTF-8 strings.
final class YXmlAttr extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> value;
}

/// A structure representing a binary to be destroyed via `ybinary_destroy`.
final class YBinaryDestroyInput extends ffi.Struct {
  external ffi.Pointer<ffi.Char> binary_ptr;

  @ffi.Uint32()
  external int binary_len;
}

/// Struct representing a state of a document. It contains the last seen clocks for blocks submitted
/// per any of the clients collaborating on document updates.
final class YStateVector extends ffi.Struct {
  /// Number of clients. It describes a length of both `client_ids` and `clocks` arrays.
  @ffi.Uint32()
  external int entries_count;

  /// Array of unique client identifiers (length is given in `entries_count` field). Each client
  /// ID has corresponding clock attached, which can be found in `clocks` field under the same
  /// index.
  external ffi.Pointer<ffi.Uint64> client_ids;

  /// Array of clocks (length is given in `entries_count` field) known for each client. Each clock
  /// has a corresponding client identifier attached, which can be found in `client_ids` field
  /// under the same index.
  external ffi.Pointer<ffi.Uint32> clocks;
}

final class YIdRange extends ffi.Struct {
  @ffi.Uint32()
  external int start;

  @ffi.Uint32()
  external int end;
}

/// Fixed-length sequence of ID ranges. Each range is a pair of [start, end) values, describing the
/// range of items identified by clock values, that this range refers to.
final class YIdRangeSeq extends ffi.Struct {
  /// Number of ranges stored in this sequence.
  @ffi.Uint32()
  external int len;

  /// Array (length is stored in `len` field) or ranges. Each range is a pair of [start, end)
  /// values, describing continuous collection of items produced by the same client, identified
  /// by clock values, that this range refers to.
  external ffi.Pointer<YIdRange> seq;
}

/// Delete set is a map of `(ClientID, Range[])` entries. Length of a map is stored in
/// `entries_count` field. ClientIDs reside under `client_ids` and their corresponding range
/// sequences can be found under the same index of `ranges` field.
final class YDeleteSet extends ffi.Struct {
  /// Number of client identifier entries.
  @ffi.Uint32()
  external int entries_count;

  /// Array of unique client identifiers (length is given in `entries_count` field). Each client
  /// ID has corresponding sequence of ranges attached, which can be found in `ranges` field under
  /// the same index.
  external ffi.Pointer<ffi.Uint64> client_ids;

  /// Array of range sequences (length is given in `entries_count` field). Each sequence has
  /// a corresponding client ID attached, which can be found in `client_ids` field under
  /// the same index.
  external ffi.Pointer<YIdRangeSeq> ranges;
}

/// Event generated for callbacks subscribed using `ydoc_observe_after_transaction`. It contains
/// snapshot of changes made within any committed transaction.
final class YAfterTransactionEvent extends ffi.Struct {
  /// Descriptor of a document state at the moment of creating the transaction.
  external YStateVector before_state;

  /// Descriptor of a document state at the moment of committing the transaction.
  external YStateVector after_state;

  /// Information about all items deleted within the scope of a transaction.
  external YDeleteSet delete_set;
}

final class YSubdocsEvent extends ffi.Struct {
  @ffi.Uint32()
  external int added_len;

  @ffi.Uint32()
  external int removed_len;

  @ffi.Uint32()
  external int loaded_len;

  external ffi.Pointer<ffi.Pointer<YDoc>> added;

  external ffi.Pointer<ffi.Pointer<YDoc>> removed;

  external ffi.Pointer<ffi.Pointer<YDoc>> loaded;
}

/// Structure containing unapplied update data.
/// Created via `ytransaction_pending_update`.
/// Released via `ypending_update_destroy`.
final class YPendingUpdate extends ffi.Struct {
  /// A state vector that informs about minimal client clock values that need to be satisfied
  /// in order to successfully apply current update.
  external YStateVector missing;

  /// Update data stored in lib0 v1 format.
  external ffi.Pointer<ffi.Char> update_v1;

  /// Length of `update_v1` payload.
  @ffi.Uint32()
  external int update_len;
}

final class YMapInputData extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Char>> keys;

  external ffi.Pointer<YInput> values;
}

/// A data structure that is used to pass input values of various types supported by Yrs into a
/// shared document store.
///
/// `YInput` constructor function don't allocate any resources on their own, neither they take
/// ownership by pointers to memory blocks allocated by user - for this reason once an input cell
/// has been used, its content should be freed by the caller.
final class YInput extends ffi.Struct {
  /// Tag describing, which `value` type is being stored by this input cell. Can be one of:
  ///
  /// - [Y_JSON] for a UTF-8 encoded, NULL-terminated JSON string.
  /// - [Y_JSON_BOOL] for boolean flags.
  /// - [Y_JSON_NUM] for 64-bit floating point numbers.
  /// - [Y_JSON_INT] for 64-bit signed integers.
  /// - [Y_JSON_STR] for null-terminated UTF-8 encoded strings.
  /// - [Y_JSON_BUF] for embedded binary data.
  /// - [Y_JSON_ARR] for arrays of JSON-like values.
  /// - [Y_JSON_MAP] for JSON-like objects build from key-value pairs.
  /// - [Y_JSON_NULL] for JSON-like null values.
  /// - [Y_JSON_UNDEF] for JSON-like undefined values.
  /// - [Y_ARRAY] for cells which contents should be used to initialize a `YArray` shared type.
  /// - [Y_MAP] for cells which contents should be used to initialize a `YMap` shared type.
  /// - [Y_DOC] for cells which contents should be used to nest a `YDoc` sub-document.
  /// - [Y_WEAK_LINK] for cells which contents should be used to nest a `YWeakLink` sub-document.
  @ffi.Int8()
  external int tag;

  /// Length of the contents stored by current `YInput` cell.
  ///
  /// For [Y_JSON_NULL] and [Y_JSON_UNDEF] its equal to `0`.
  ///
  /// For [Y_JSON_ARR], [Y_JSON_MAP], [Y_ARRAY] and [Y_MAP] it describes a number of passed
  /// elements.
  ///
  /// For other types it's always equal to `1`.
  @ffi.Uint32()
  external int len;

  /// Union struct which contains a content corresponding to a provided `tag` field.
  external YInputContent value;
}

final class YInputContent extends ffi.Union {
  @ffi.Uint8()
  external int flag;

  @ffi.Double()
  external double num;

  @ffi.Int64()
  external int integer;

  external ffi.Pointer<ffi.Char> str;

  external ffi.Pointer<ffi.Char> buf;

  external ffi.Pointer<YInput> values;

  external YMapInputData map;

  external ffi.Pointer<YDoc> doc;

  external ffi.Pointer<Weak> weak;
}

typedef Weak = LinkSource;

/// A data type representing a single change to be performed in sequence of changes defined
/// as parameter to a `ytext_insert_delta` function. A type of change can be detected using
/// a `tag` field:
///
/// 1. `Y_EVENT_CHANGE_ADD` marks a new characters added to a collection. In this case `insert`
/// field contains a pointer to a list of newly inserted values, while `len` field informs about
/// their count. Additionally `attributes_len` nad `attributes` carry information about optional
/// formatting attributes applied to edited blocks.
/// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this case
/// `len` field informs about number of removed elements.
/// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of characters that have not been changed, counted from
/// the previous element. `len` field informs about number of retained elements. Additionally
/// `attributes_len` nad `attributes` carry information about optional formatting attributes applied
/// to edited blocks.
final class YDeltaIn extends ffi.Struct {
  /// Tag field used to identify particular type of change made:
  ///
  /// 1. `Y_EVENT_CHANGE_ADD` marks a new elements added to a collection. In this case `values`
  /// field contains a pointer to a list of newly inserted values, while `len` field informs about
  /// their count.
  /// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this
  /// case `len` field informs about number of removed elements.
  /// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of elements that have not been changed, counted
  /// from the previous element. `len` field informs about number of retained elements.
  @ffi.Uint8()
  external int tag;

  /// Number of element affected by current type of change. It can refer to a number of
  /// inserted `values`, number of deleted element or a number of retained (unchanged) values.
  @ffi.Uint32()
  external int len;

  /// A nullable pointer to a list of formatting attributes assigned to an edited area represented
  /// by this delta.
  external ffi.Pointer<YInput> attributes;

  /// Used in case when current change is of `Y_EVENT_CHANGE_ADD` type. Contains a list (of
  /// length stored in `len` field) of newly inserted values.
  external ffi.Pointer<YInput> insert;
}

/// A chunk of text contents formatted with the same set of attributes.
final class YChunk extends ffi.Struct {
  /// Piece of YText formatted using the same `fmt` rules. It can be a string, embedded object
  /// or another y-type.
  external YOutput data;

  /// Number of formatting attributes attached to current chunk of text.
  @ffi.Uint32()
  external int fmt_len;

  /// The formatting attributes attached to the current chunk of text.
  external ffi.Pointer<YMapEntry> fmt;
}

/// Event pushed into callbacks registered with `ytext_observe` function. It contains delta of all
/// text changes made within a scope of corresponding transaction (see: `ytext_event_delta`) as
/// well as navigation data used to identify a `YText` instance which triggered this event.
final class YTextEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

/// Event pushed into callbacks registered with `ymap_observe` function. It contains all
/// key-value changes made within a scope of corresponding transaction (see: `ymap_event_keys`) as
/// well as navigation data used to identify a `YMap` instance which triggered this event.
final class YMapEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

/// Event pushed into callbacks registered with `yarray_observe` function. It contains delta of all
/// content changes made within a scope of corresponding transaction (see: `yarray_event_delta`) as
/// well as navigation data used to identify a `YArray` instance which triggered this event.
final class YArrayEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

/// Event pushed into callbacks registered with `yxmlelem_observe` function. It contains
/// all attribute changes made within a scope of corresponding transaction
/// (see: `yxmlelem_event_keys`) as well as child XML nodes changes (see: `yxmlelem_event_delta`)
/// and navigation data used to identify a `YXmlElement` instance which triggered this event.
final class YXmlEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

/// Event pushed into callbacks registered with `yxmltext_observe` function. It contains
/// all attribute changes made within a scope of corresponding transaction
/// (see: `yxmltext_event_keys`) as well as text edits (see: `yxmltext_event_delta`)
/// and navigation data used to identify a `YXmlText` instance which triggered this event.
final class YXmlTextEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

/// Event pushed into callbacks registered with `yweak_observe` function. It contains
/// all an event changes of the underlying transaction.
final class YWeakLinkEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> inner;

  external ffi.Pointer<TransactionMut> txn;
}

final class YEventContent extends ffi.Union {
  external YTextEvent text;

  external YMapEvent map;

  external YArrayEvent array;

  external YXmlEvent xml_elem;

  external YXmlTextEvent xml_text;

  external YWeakLinkEvent weak;
}

final class YEvent extends ffi.Struct {
  /// Tag describing, which shared type emitted this event.
  ///
  /// - [Y_TEXT] for pointers to `YText` data types.
  /// - [Y_ARRAY] for pointers to `YArray` data types.
  /// - [Y_MAP] for pointers to `YMap` data types.
  /// - [Y_XML_ELEM] for pointers to `YXmlElement` data types.
  /// - [Y_XML_TEXT] for pointers to `YXmlText` data types.
  @ffi.Int8()
  external int tag;

  /// A nested event type, specific for a shared data type that triggered it. Type of an
  /// event can be verified using `tag` field.
  external YEventContent content;
}

final class YPathSegmentCase extends ffi.Union {
  external ffi.Pointer<ffi.Char> key;

  @ffi.Uint32()
  external int index;
}

/// A single segment of a path returned from `yevent_path` function. It can be one of two cases,
/// recognized by it's `tag` field:
///
/// 1. `Y_EVENT_PATH_KEY` means that segment value can be accessed by `segment.value.key` and is
/// referring to a string key used by map component (eg. `YMap` entry).
/// 2. `Y_EVENT_PATH_INDEX` means that segment value can be accessed by `segment.value.index` and is
/// referring to an int index used by sequence component (eg. `YArray` item or `YXmlElement` child).
final class YPathSegment extends ffi.Struct {
  /// Tag used to identify which case current segment is referring to:
  ///
  /// 1. `Y_EVENT_PATH_KEY` means that segment value can be accessed by `segment.value.key` and is
  /// referring to a string key used by map component (eg. `YMap` entry).
  /// 2. `Y_EVENT_PATH_INDEX` means that segment value can be accessed by `segment.value.index`
  /// and is referring to an int index used by sequence component (eg. `YArray` item or
  /// `YXmlElement` child).
  @ffi.Char()
  external int tag;

  /// Union field containing either `key` or `index`. A particular case can be recognized by using
  /// segment's `tag` field.
  external YPathSegmentCase value;
}

/// A single instance of formatting attribute stored as part of `YDelta` instance.
final class YDeltaAttr extends ffi.Struct {
  /// A null-terminated UTF-8 encoded string containing a unique formatting attribute name.
  external ffi.Pointer<ffi.Char> key;

  /// A value assigned to a formatting attribute.
  external YOutput value;
}

/// A data type representing a single change detected over an observed `YText`/`YXmlText`. A type
/// of change can be detected using a `tag` field:
///
/// 1. `Y_EVENT_CHANGE_ADD` marks a new characters added to a collection. In this case `insert`
/// field contains a pointer to a list of newly inserted values, while `len` field informs about
/// their count. Additionally `attributes_len` nad `attributes` carry information about optional
/// formatting attributes applied to edited blocks.
/// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this case
/// `len` field informs about number of removed elements.
/// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of characters that have not been changed, counted from
/// the previous element. `len` field informs about number of retained elements. Additionally
/// `attributes_len` nad `attributes` carry information about optional formatting attributes applied
/// to edited blocks.
///
/// A list of changes returned by `ytext_event_delta`/`yxmltext_event_delta` enables to locate
/// a position of all changes within an observed collection by using a combination of added/deleted
/// change structs separated by retained changes (marking eg. number of elements that can be safely
/// skipped, since they remained unchanged).
final class YDeltaOut extends ffi.Struct {
  /// Tag field used to identify particular type of change made:
  ///
  /// 1. `Y_EVENT_CHANGE_ADD` marks a new elements added to a collection. In this case `values`
  /// field contains a pointer to a list of newly inserted values, while `len` field informs about
  /// their count.
  /// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this
  /// case `len` field informs about number of removed elements.
  /// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of elements that have not been changed, counted
  /// from the previous element. `len` field informs about number of retained elements.
  @ffi.Uint8()
  external int tag;

  /// Number of element affected by current type of change. It can refer to a number of
  /// inserted `values`, number of deleted element or a number of retained (unchanged) values.
  @ffi.Uint32()
  external int len;

  /// A number of formatting attributes assigned to an edited area represented by this delta.
  @ffi.Uint32()
  external int attributes_len;

  /// A nullable pointer to a list of formatting attributes assigned to an edited area represented
  /// by this delta.
  external ffi.Pointer<YDeltaAttr> attributes;

  /// Used in case when current change is of `Y_EVENT_CHANGE_ADD` type. Contains a list (of
  /// length stored in `len` field) of newly inserted values.
  external ffi.Pointer<YOutput> insert;
}

/// A data type representing a single change detected over an observed shared collection. A type
/// of change can be detected using a `tag` field:
///
/// 1. `Y_EVENT_CHANGE_ADD` marks a new elements added to a collection. In this case `values` field
/// contains a pointer to a list of newly inserted values, while `len` field informs about their
/// count.
/// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this case
/// `len` field informs about number of removed elements.
/// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of elements that have not been changed, counted from
/// the previous element. `len` field informs about number of retained elements.
///
/// A list of changes returned by `yarray_event_delta`/`yxml_event_delta` enables to locate a
/// position of all changes within an observed collection by using a combination of added/deleted
/// change structs separated by retained changes (marking eg. number of elements that can be safely
/// skipped, since they remained unchanged).
final class YEventChange extends ffi.Struct {
  /// Tag field used to identify particular type of change made:
  ///
  /// 1. `Y_EVENT_CHANGE_ADD` marks a new elements added to a collection. In this case `values`
  /// field contains a pointer to a list of newly inserted values, while `len` field informs about
  /// their count.
  /// 2. `Y_EVENT_CHANGE_DELETE` marks an existing elements removed from the collection. In this
  /// case `len` field informs about number of removed elements.
  /// 3. `Y_EVENT_CHANGE_RETAIN` marks a number of elements that have not been changed, counted
  /// from the previous element. `len` field informs about number of retained elements.
  @ffi.Uint8()
  external int tag;

  /// Number of element affected by current type of a change. It can refer to a number of
  /// inserted `values`, number of deleted element or a number of retained (unchanged) values.
  @ffi.Uint32()
  external int len;

  /// Used in case when current change is of `Y_EVENT_CHANGE_ADD` type. Contains a list (of
  /// length stored in `len` field) of newly inserted values.
  external ffi.Pointer<YOutput> values;
}

/// A data type representing a single change made over a map component of shared collection types,
/// such as `YMap` entries or `YXmlText`/`YXmlElement` attributes. A `key` field provides a
/// corresponding unique key string of a changed entry, while `tag` field informs about specific
/// type of change being done:
///
/// 1. `Y_EVENT_KEY_CHANGE_ADD` used to identify a newly added entry. In this case an `old_value`
/// field is NULL, while `new_value` field contains an inserted value.
/// 1. `Y_EVENT_KEY_CHANGE_DELETE` used to identify an existing entry being removed. In this case
/// an `old_value` field contains the removed value.
/// 1. `Y_EVENT_KEY_CHANGE_UPDATE` used to identify an existing entry, which value has been changed.
/// In this case `old_value` field contains replaced value, while `new_value` contains a newly
/// inserted one.
final class YEventKeyChange extends ffi.Struct {
  /// A UTF8-encoded null-terminated string containing a key of a changed entry.
  external ffi.Pointer<ffi.Char> key;

  /// Tag field informing about type of change current struct refers to:
  ///
  /// 1. `Y_EVENT_KEY_CHANGE_ADD` used to identify a newly added entry. In this case an
  /// `old_value` field is NULL, while `new_value` field contains an inserted value.
  /// 1. `Y_EVENT_KEY_CHANGE_DELETE` used to identify an existing entry being removed. In this
  /// case an `old_value` field contains the removed value.
  /// 1. `Y_EVENT_KEY_CHANGE_UPDATE` used to identify an existing entry, which value has been
  /// changed. In this case `old_value` field contains replaced value, while `new_value` contains
  /// a newly inserted one.
  @ffi.Char()
  external int tag;

  /// Contains a removed entry's value or replaced value of an updated entry.
  external ffi.Pointer<YOutput> old_value;

  /// Contains a value of newly inserted entry or an updated entry's new value.
  external ffi.Pointer<YOutput> new_value;
}

final class YUndoManagerOptions extends ffi.Struct {
  @ffi.Int32()
  external int capture_timeout_millis;
}

/// Event type related to `UndoManager` observer operations, such as `yundo_manager_observe_popped`
/// and `yundo_manager_observe_added`. It contains various informations about the context in which
/// undo/redo operations are executed.
final class YUndoEvent extends ffi.Struct {
  /// Informs if current event is related to executed undo (`Y_KIND_UNDO`) or redo (`Y_KIND_REDO`)
  /// operation.
  @ffi.Char()
  external int kind;

  /// Origin assigned to a transaction, in context of which this event is being executed.
  /// Transaction origin is specified via `ydoc_write_transaction(doc, origin_len, origin)`.
  external ffi.Pointer<ffi.Char> origin;

  /// Length of an `origin` field assigned to a transaction, in context of which this event is
  /// being executed.
  /// Transaction origin is specified via `ydoc_write_transaction(doc, origin_len, origin)`.
  @ffi.Uint32()
  external int origin_len;

  /// Pointer to a custom metadata object that can be passed between
  /// `yundo_manager_observe_popped` and `yundo_manager_observe_added`. It's useful for passing
  /// around custom user data ie. cursor position, that needs to be remembered and restored as
  /// part of undo/redo operations.
  ///
  /// This field always starts with no value (`NULL`) assigned to it and can be set/unset in
  /// corresponding callback calls. In such cases it's up to a programmer to handle allocation
  /// and deallocation of memory that this pointer will point to. Not releasing it properly may
  /// lead to memory leaks.
  external ffi.Pointer<ffi.Void> meta;
}

final class YBranchIdVariant extends ffi.Union {
  /// Clock number timestamp when the creator of a nested shared type created it.
  @ffi.Uint32()
  external int clock;

  /// Pointer to UTF-8 encoded string representing root-level type name. This pointer is valid
  /// as long as document - in which scope it was created in - was not destroyed. As usually
  /// root-level type names are statically allocated strings, it can also be supplied manually
  /// from the outside.
  external ffi.Pointer<ffi.Uint8> name;
}

/// A structure representing logical identifier of a specific shared collection.
/// Can be obtained by `ybranch_id` executed over alive `Branch`.
///
/// Use `ybranch_get` to resolve a `Branch` pointer from this branch ID.
///
/// This structure doesn't need to be destroyed. It's internal pointer reference is valid through
/// a lifetime of a document, which collection this branch ID has been created from.
final class YBranchId extends ffi.Struct {
  /// If positive: Client ID of a creator of a nested shared type, this identifier points to.
  /// If negative: a negated Length of a root-level shared collection name.
  @ffi.Int64()
  external int client_or_len;

  external YBranchIdVariant variant;
}

/// Transaction is one of the core types in Yrs. All operations that need to touch or
/// modify a document's contents (a.k.a. block store), need to be executed in scope of a
/// transaction.
typedef YTransaction = TransactionInner;

/// A sticky index is based on the Yjs model and is not affected by document changes.
/// E.g. If you place a sticky index before a certain character, it will always point to this character.
/// If you place a sticky index at the end of a type, it will always point to the end of the type.
///
/// A numeric position is often unsuited for user selections, because it does not change when content is inserted
/// before or after.
///
/// ```Insert(0, 'x')('a.bc') = 'xa.bc'``` Where `.` is the sticky index position.
///
/// Instances of `YStickyIndex` can be freed using `ysticky_index_destroy`.
typedef YStickyIndex = StickyIndex;

const int __GNUC_VA_LIST = 1;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __WORDSIZE = 64;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 0;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 0;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_64_BIT_INO_T = '\$INODE64';

const String __DARWIN_SUF_1050 = '\$1050';

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 140000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 140500;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _I386_SIGNAL_H_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int FP_PREC_24B = 0;

const int FP_PREC_53B = 2;

const int FP_PREC_64B = 3;

const int FP_RND_NEAR = 0;

const int FP_RND_DOWN = 1;

const int FP_RND_UP = 2;

const int FP_CHOP = 3;

const int FP_STATE_BYTES = 512;

const int _X86_INSTRUCTION_STATE_MAX_INSN_BYTES = 2380;

const int _X86_INSTRUCTION_STATE_CACHELINE_SIZE = 64;

const int __LASTBRANCH_MAX = 32;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int Y_JSON = -9;

const int Y_JSON_BOOL = -8;

const int Y_JSON_NUM = -7;

const int Y_JSON_INT = -6;

const int Y_JSON_STR = -5;

const int Y_JSON_BUF = -4;

const int Y_JSON_ARR = -3;

const int Y_JSON_MAP = -2;

const int Y_JSON_NULL = -1;

const int Y_JSON_UNDEF = 0;

const int Y_ARRAY = 1;

const int Y_MAP = 2;

const int Y_TEXT = 3;

const int Y_XML_ELEM = 4;

const int Y_XML_TEXT = 5;

const int Y_XML_FRAG = 6;

const int Y_DOC = 7;

const int Y_WEAK_LINK = 8;

const int Y_UNDEFINED = 9;

const int Y_TRUE = 1;

const int Y_FALSE = 0;

const int Y_OFFSET_BYTES = 0;

const int Y_OFFSET_UTF16 = 1;

const int ERR_CODE_IO = 1;

const int ERR_CODE_VAR_INT = 2;

const int ERR_CODE_EOS = 3;

const int ERR_CODE_UNEXPECTED_VALUE = 4;

const int ERR_CODE_INVALID_JSON = 5;

const int ERR_CODE_OTHER = 6;

const int ERR_NOT_ENOUGH_MEMORY = 7;

const int ERR_TYPE_MISMATCH = 8;

const int ERR_CUSTOM = 9;

const int ERR_INVALID_PARENT = 9;

const int YCHANGE_ADD = 1;

const int YCHANGE_RETAIN = 0;

const int YCHANGE_REMOVE = -1;

const int Y_KIND_UNDO = 0;

const int Y_KIND_REDO = 1;

const int Y_EVENT_PATH_KEY = 1;

const int Y_EVENT_PATH_INDEX = 2;

const int Y_EVENT_CHANGE_ADD = 1;

const int Y_EVENT_CHANGE_DELETE = 2;

const int Y_EVENT_CHANGE_RETAIN = 3;

const int Y_EVENT_KEY_CHANGE_ADD = 4;

const int Y_EVENT_KEY_CHANGE_DELETE = 5;

const int Y_EVENT_KEY_CHANGE_UPDATE = 6;
